# BootLoader引导启动程序

## Boot引导程序

### 写一个Boot引导程序

#### 起始地址

```assembly
org 0x7c00
BaseOfStack equ 0x7c00
```

#### 初始化

```assembly
mov ax, cs
mov ds, ax
mov es, ax
mov ss, ax
mov sp, BaseOfStack
```

进行地址段寄存器（ds）、附加段寄存器（es）、堆栈段寄存器（ss）初始化，并将堆栈指针（sp）初始化为BaseOfStack，代表引导程序地址设在0x7c00处。

#### BIOS中断服务

使用x86汇编语言INT指令

该os常用的BIOS 中断向解释：

-    **INT 10h**

显示服务 ， 由BIOS或操作系统设定以供软件调用。AH=00h 设定显示模式；AH=01h 设定游标形态；AH=02h 设置游标位置；AH=03h 获取光标位置与形态；AH=04h 获取光标位置；AH=05h 设置显示页；AH=06h 清除或滚动栏画面(上)；AH=07h 清除或滚动栏画面(下)；AH=08h 读取游标处字符与属性；AH=09h 更改游标处字符与属性；AH=0Ah 更改游标处字符；AH=0Bh 设定边界颜色；AH=0Eh 在TTY模式下写字符；AH=0Fh 获取当前显示模式；AH=13h 写字符串。

-   **INT 13h**

低级磁盘服务。AH=00h 复位磁盘驱动器；AH=01h 检查磁盘驱动器状态；AH=02h 读扇区；AH=03h 写扇区；AH=04h 校验扇区；AH=05h 格式化磁道；AH=08h 获取驱动器参数；AH=09h 初始化硬盘驱动器参数；AH=0Ch 寻道；AH=0Dh 复位硬盘控制器；AH=15h 获取驱动器类型；AH=16h 获取软驱中盘片的状态。

-   **INT 15h**

其它（系统支持例程）。AH=4FH 键盘拦截；AH=83H事件等待；AH=84H读游戏杆；AH=85HSysRq 键；AH=86H等待；AH=87H块移动；AH=88H获取扩展内存容量；AH=C0H获取系统参数；AH=C1H获取扩展 BIOS 数据区段；AH=C2H指针设备功能；AH=E8h, AL=01h (AX = E801h)获取扩展内存容量（自从 1994 年引入的新功能），可获取到 64MB 以上的内存容量；AH=E8h, AL=20h (AX = E820h)查询系统地址映射；该功能取代了 AX=E801h 和 AH=88h。

#### 清屏

```assembly
mov ax, 0600h  ;06，按指定范围滚动窗口
mov bx, 0700h 
mov cx, 0
mov dx, 0184fh
int 10h
```

在接下来程序中

**AX**: 用于指定调用哪个的子功能。

**BX**: 通常用于设置文本和背景的颜色属性。

**CX**: 通常用于指定要操作的字符数或其他数量。

**DX**: 通常用于设置光标的位置。



**AH=06h** 清除或滚动栏画面

**0700h=0000 0111**

依照BH=颜色属性

-   bit 0~2:字体颜色（0:黑，1:蓝，2:绿，3:青，4:红，5:紫，6:综，7:白)。
-   bit 3:字体亮度(0:字体正常，1:字体高亮度)
-   bit 4~6:背景颜色（0:黑，1:蓝，2:绿，3:青，4:红，5:紫，6:综，7:白)。
-   bit 7:字体闪烁(0:不闪烁，1:字体闪烁)。

bit 0~2为111，即白色字体；bit 3为0，即字体正常；bit 4~6为000，即黑色背景；bit 7为0，即字体不闪烁

#### 光标

```assembly
mov ax, 0200h
mov bx, 0000h
mov dx, 0000h
int 10h
```

**AH=02h** 设置游标位置

**mov bx, 0000h**、**mov dx, 0000h ** 代表光标位置位于屏幕左上角（0,0）处

#### 初始屏幕

```assembly
mov ax, 1301h
mov bx, 000fh
mov dx, 0000h
mov cx, 10
push ax
mov ax, ds
mov es, ax
pop ax
mov bp, StartBootMessage 
int 10h
```

**AH=13h **写字符串

**AL=01h** 光标会移到字符串尾端位置（**AL=00h** 光标会移到字符串前端位置）

**mov cx, 10** 字符串长度为10（该字符串是StartBootMessage）

**mov bp, StartBootMessage ** 将StartBootMessage 写入bp

#### 复位

```assembly
xor ah,ah
xor dl,dl
int 13h
	
jmp $
```

**xor**是异或，将ah和dl清0

#### 填充

```assembly
times 510-($-$$) db 0 ;$-$$ 
dw 0xaa55
```

将当前行被编译后的地址（机器码地址)减去本节 ( Section）程序的起始地址，将521B空间（扇区单位）填充

**0xaa55**引导扇区是以0xaa、0x55为结尾（默认），又因为Inter处理器是小段模式存储，所以这样写

### 创建虚拟软盘镜像

利用Bochs虚拟机自带的虚拟磁盘镜像创建工具bximage

运行命令

```bash
@ubuntu:~/Desktop$ bximage
========================================================================
                                bximage
  Disk Image Creation / Conversion / Resize and Commit Tool for Bochs
         $Id: bximage.cc 13069 2017-02-12 16:51:52Z vruppert $
========================================================================

1. Create new floppy or hard disk image
2. Convert hard disk image to other format (mode)
3. Resize hard disk image
4. Commit 'undoable' redolog to base image
5. Disk image info

0. Quit

Please choose one [0] 1

Create image

Do you want to create a floppy disk image or a hard disk image?
Please type hd or fd. [hd] fd

Choose the size of floppy disk image to create.
Please type 160k, 180k, 320k, 360k, 720k, 1.2M, 1.44M, 1.68M, 1.72M, or 2.88M.
 [1.44M] 

What should be the name of the image?
[a.img] boot.img

Creating floppy image 'boot.img' with 2880 sectors

The following line should appear in your bochsrc:
  floppya: image="boot.img", status=inserted
```

选择1，fd，软盘容量1.44MB是通用的3.5英寸软盘，然后对镜像文件取名

接下来可以选择5去查看磁盘信息，不过感觉内存少了点。查阅资料，正常3.5英寸软盘的容量是1.44 MB=1440×1024KB=1474560 B，软盘共包含2个磁头、80个磁道、18个扇区。此处的bximage工具只正确解析出虚拟磁盘容量是1474560 B，bximage工具是按照1MB进行计算的，确实不大对，不过应该不影响？

### 运行Boot程序

#### 编译引导程序

```bash
nasm boot.asm -o boot.bin
```

#### 使用dd命令把引导程序写入引导扇区

```bash
dd if=boot.bin of=./bochs-2.6.8/boot.img bs=512 count=1 conv=notrunc
```

运行成功

```bash
(root@localhost 1]# dd if=boot.bin of=./bochs-2.6.9/boot.img bs=512 count=1 conv=notrunc
1+0 records in
1+0 records out
512 bytes (512 B) copied, 0.000155041 s,2.2 MB/s 
```

成功的样子大概这样

#### bochs命令启动虚拟机

```bash
bochs -f ./bochsrc
```

这里的**bochsrc**我在**bochs-2.6.9**文件夹中没有找到，运行这个命令也会报错，我就上网搜了一下，发现这个**bochsrc**并不存在，需要自己写

#### bochsrc文件

终端输入生成文件

```bash
vi bochsrc
```

bochsrc内容为

```bash
# configuration file generated by Bochs
plugin_ctrl: unmapped=1, biosdev=1, speaker=1, extfpuirq=1, parallel=1, serial=1, iodebug=1
config_interface: textconfig
display_library: x
#memory: host=2048, guest=2048
romimage: file="/usr/local/share/bochs/BIOS-bochs-latest"
vgaromimage: file="/usr/local/share/bochs/VGABIOS-lgpl-latest"
boot: floppy
floppy_bootsig_check: disabled=0
floppya: type=1_44, 1_44="boot.img", status=inserted, write_protected=0
# no floppyb
ata0: enabled=1, ioaddr1=0x1f0, ioaddr2=0x3f0, irq=14
ata0-master: type=none
ata0-slave: type=none
ata1: enabled=1, ioaddr1=0x170, ioaddr2=0x370, irq=15
ata1-master: type=none
ata1-slave: type=none
ata2: enabled=0
ata3: enabled=0
pci: enabled=1, chipset=i440fx
vga: extension=vbe, update_freq=5

cpu: count=1:1:1, ips=4000000, quantum=16, model=corei7_haswell_4770,reset_on_triple_fault=1, cpuid_limit_winnt=0, ignore_bad_msrs=1, mwait_is_nop=0, msrs="msrs.def"

cpuid: x86_64=1,level=6, mmx=1, sep=1, simd=avx512, aes=1, movbe=1, xsave=1,apic=x2apic,sha=1,movbe=1,adx=1,xsaveopt=1,avx_f16c=1,avx_fma=1,bmi=bmi2,1g_pages=1,pcid=1,fsgsbase=1,smep=1,smap=1,mwait=1,vmx=1
cpuid: family=6, model=0x1a, stepping=5, vendor_string="GenuineIntel", brand_string="Intel(R) Core(TM) i7-4770 CPU (Haswell)"

print_timestamps: enabled=0
debugger_log: -
magic_break: enabled=0
port_e9_hack: enabled=0
private_colormap: enabled=0
clock: sync=none, time0=local, rtc_sync=0
# no cmosimage
# no loader
log: -
logprefix: %t%e%d
debug: action=ignore
info: action=report
error: action=report
panic: action=ask
keyboard: type=mf, serial_delay=250, paste_delay=100000, user_shortcut=none
mouse: type=ps2, enabled=0, toggle=ctrl+mbutton
speaker: enabled=1, mode=system
parport1: enabled=1, file=none
parport2: enabled=0
com1: enabled=1, mode=null
com2: enabled=0
com3: enabled=0
com4: enabled=0

megs: 2048
```

这个文件配置网上有很多说法，但是我通过后面一些debug发现这个是最合适的，其他会出错

然后ESC输入”:wq“保存就可以了

然后运行

```bash
bochs -f ./bochsrc
```

生成成功后大概是这样

```bash
@ubuntu:~/bochs-2.6.9$ bochs -f ./bochsrc
========================================================================
                       Bochs x86 Emulator 2.6.9
               Built from SVN snapshot on April 9, 2017
                  Compiled on Aug 15 2023 at 23:59:28
========================================================================
00000000000i[      ] BXSHARE not set. using compile time default '/usr/local/share/bochs'
00000000000i[      ] reading configuration from ./bochsrc
------------------------------
Bochs Configuration: Main Menu
------------------------------

This is the Bochs Configuration Interface, where you can describe the
machine that you want to simulate.  Bochs has already searched for a
configuration file (typically called bochsrc.txt) and loaded it if it
could be found.  When you are satisfied with the configuration, go
ahead and start the simulation.

You can also start bochs with the -q option to skip these menus.

1. Restore factory default configuration
2. Read options from...
3. Edit options
4. Save options to...
5. Restore the Bochs state from...
6. Begin simulation
7. Quit now

Please choose one: [6] 

```

默认选择6（表示开始运行虚拟机）

#### 运行

刚开始就是黑框

![image-20230830205648163](https://raw.githubusercontent.com/Enid1107/TyporaImgBed/main/Img/202308302056266.png)

然后在终端输入c/cont/continue任意一个就行

![boot运行成功](https://raw.githubusercontent.com/Enid1107/TyporaImgBed/main/Img/202308302058605.png)

ok，引导程序运行成功

## 加载Loader到内存

选择FAT12文件系统来装载Loader程序和内核程序

FAT类文件系统会对软盘里的扇区进行结构化处理，进而把软盘扇区划分成引导扇区、FAT表、根目录区和数据区4部分。

![软盘文件系统分配图](https://raw.githubusercontent.com/Enid1107/TyporaImgBed/main/Img/202308311250475.png)

### 加载Loader到内存

#### 引导扇区

```assembly
jmp short Lable_Start
nop
BS_OEMName 		db 'Mi64boot'
BPB_BytesPerSec dw 512
BPB_SecPerClus  db 1
BPB_RsvdSecCnt  dw 1
BPB_NumFATs 	db 2
BPB_RootEntCnt  dw 224
BPB_TotSec16 	dw 2880
BPB_Media 		db 0xf0
BPB_FATSz16 	dw 9
BPB_SecPerTrk 	dw 18
BPB_NumHeads 	dw 2
BPB_hiddSec 	dd 0
BPB_TotSec32 	dd 0
BS_DrvNum 		db 0
BS_Reserved1 	db 0
BS_BootSig 		db 29h
BS_VolTD 		dd 0
BS_VolLab 		db 'boot loader'
BS_FileSysType  db 'FAT12'
```

**jmp short Lable_Start** 无条件短跳转指令，使程序跳到标签 label_start指向的代码地址开始执行

**BS_OEMName **生产厂商名，自定义取名

**BPB_BytesPerSec** 每扇区字节数，一个扇区为512B

**BPB_SecPerClus** 每簇扇区数。簇是FAT类文件系统的最小存储单位

**BPB_RsvdSecCnt** 保留扇区数，保留扇区起始于FAT12文件系统的第一个扇区，引导扇区包含在保留扇区内，FAT表从软盘的第二个扇区开始。

**BPB_NumFATs** FAT12文件系统中FAT表的份数，建议FAT类文件都设为2，给FAT表准备备份表

**BPB_RootEntCnt** 根目录可容纳的目录项数，

**BPB_TotSec16** 如果总扇区数小于65536，则为总扇区数

**BPB_Media ** 媒体类型

**BPB_FATSz16** 每个FAT表的扇区数

**BPB_SecPerTrk** 每磁道的扇区数

**BPB_NumHeads** 硬盘的磁头数

**BPB_hiddSec** 分区之前的隐藏扇区数

**BPB_TotSec32** 如果总扇区数大于65535，则为总扇区数

**BS_DrvNum** 驱动器号

**BS_Reserved1** 保留字节

**BS_BootSig** 引导签名，值为`29h`表示后面是卷序列号、卷标和文件系统类型

**BS_VolTD** 卷序列号

**BS_VolLab** 卷标

**BS_FileSysType** 文件系统类型，这里为"FAT12"

#### Loader中的数据定义

**起始地址**

```assembly
BaseOfLoader equ 0x10000
OffsetOfLoader equ 0x00
```

Loader的起始物理地址为：BaseOfLoader << 4 + OffsetOfLoader = 0x10000

**根目录占用扇区数**

```assembly
RootDirSectors equ 14
```

计算公式：BPB_RootEntCnt * 32 + BPB_BytesPerSec

**根目录起始扇区号**

```assembly
SectorNumOfRootDirStart equ 19
```

计算公式：保留扇区数 + FAT表扇区数 * FAT表份数 = 1 + 9 *  2 = 19

因为从0开始，所以接下来就从19开始

**FAT1表起始扇区号**

```assembly
SectorNumOfFAT1Start equ 1
```

前面说了保留扇区起始于FAT12文件系统的第一个扇区，所以起始我们就用第二个。而扇区编号从0开始，所以这个值为1

**平衡文件（或者目录）的起始簇号与数据区起始簇号的差值**

```assembly
SectorBalance equ 17
```

在FAT12中FAT[0]和FAT[1]是保留项，不能用于数据区的簇索引

为了正确计算出FAT表项对应的数据区起始扇区号，则必须将FAT表项值减2

这里将根目录起始扇区减2（19 - 2 = 17），就等于间接把数据区的起始扇区号（数据区起始扇区号=根目录起始扇区号+根目录所占扇区数）减2

#### 软盘读取

```assembly
Func_ReadOneSector:
	push bp
	mov bp, sp
	sub esp, 2 
	mov byte [bp-2], cl
	push bx 
	mov bl, [BPB_SecPerTrk]
	div bl
	inc ah
	mov cl, ah
	mov dh, al
	shr al, 1
	mov ch, al
	and dh, 1
	pop bx
	mov dl, [BS_DrvNum]
Label_Go_On_Reading:
	mov ah, 2
	mov al, byte [bp-2]
	int 13h
	jc Label_Go_On_Reading
	add esp, 2
	pop bp
	ret
```

用到了BIOS中断服务的**INT 13h**

**AH=02h** 是读取磁盘扇区

因为Func_ReadOnesector模块传入的磁盘扇区号是LBA(Logical Block Address，逻辑块寻址)格式的，而INT 13h，AH=02h中断服务程序只能受理CHS (Cylinder/Head/Sector，柱面/磁头/扇区)格式的磁盘扇区号，那么必须将LBA格式转换为CHS格式

转换公式为：

![img](https://raw.githubusercontent.com/Enid1107/TyporaImgBed/main/Img/202308311503093.png)

读取软盘前需要先保存栈帧寄存器和栈寄存器的数值，可以利用**[bp-2]** 开辟两个空间放

**div bl** 代表ax/bl，并将值存在ax中，即计算出目标磁道号

**inc ah** 将ax/bl余存入ah中，即目标磁道内的起始扇区号，磁道内的起始扇区号从1开始计数，故此将余数值加1

#### 编译

与编译boot.asm程序相似

```bash
nasm loader.asm -o loader.bin
```

#### loader.bin复制到虚拟软盘镜像文件boot.img中

借助挂载命令**mount**和复制命令**cp**，把引导加载程序loader.bin复制到文件系统中

```bash
sudo mount -o loop ./bochs-2.6.8/boot.img /media/img
sudo cp loader.bin  /media/img
sudo sync
sudo umount /media/img
```

运行成功如下：

![48Y6NWIK{`X5EU{1D`FU2TK](https://raw.githubusercontent.com/Enid1107/TyporaImgBed/main/Img/202309011341263.png)

**补充：** 

#### boot.img格式化

```bash
sudo mkfs.ext4 boot.img
```



## Loader引导加载程序

### Loader原理

Loader引导加载程序负责检测硬件信息、处理器模式切换、向内核传递数据三部分工作，这些工作为内核的初始化提供信息及功能支持，以便内核在完成初始化工作后能够正常运行

#### 检测硬件信息

Loader引导加载程序主要是通过BIOS中断服务程序来获取和检测硬件信息。

**为什么获取和检测硬件信息？**

由于BIOS在上电自检出的大部分信息只能在实模式下获取，而且内核运行于非实模式下，那么就必须在进入内核程序前将这些信息检测出来，再作为参数提供给内核程序使用

#### 处理器模式切换

**Loader引导加载程序必须历经的三个模式**

BIOS运行的实模式( real mode )-->32位操作系统使用的保护模式( protect mode)-->64位操作系统使用的IA-32e模式( long mode，长模式)

在各个模式的切换过程中，Loader引导加载程序必须手动创建各运行模式的临时数据，并按照标准流程执行模式间的跳转。此外还需要配置系统临时页表的工作（根据各个阶段的页表特性设置临时页表项，还要保证页表覆盖的地址空间满足程序使用要求）

#### 向内核传递数据

Loader引导加载程序可向内核程序传递两类数据，一类是控制信息（控制内核程序的执行流程），另一类是硬件数据信息（为内核程序的初始化提供数据信息支持）

### 写一个Loader程序

#### 基础数据和头文件

```assembly
org	10000h
	jmp Label_Start 
	
%include "fat12.inc"

BaseOfKernelFile		equ	0x00
OffsetOfKernelFile		equ	0x100000
BaseTmpOfKernelAddr		equ	0x00
OffsetTmpOfKernelFile	equ	0x7E00
MemoryStructBufferAddr	equ	0x7E00
```

**%include "fat12.inc"**  预处理器指令，它会将"fat12.inc"文件的内容包含在这个位置。"fat12.inc"文件是从Boot引导程序中提取出的FAT12文件系统结构

**BaseOfKernelFile**  内核文件的基地址

**OffsetOfKernelFile**  内核文件的偏移地址。0x100000=1MB，因为1 MB以下的物理地址并不全是可用内存地址空间，这段物理地址被划分成若干个子空间段，它们可以是内存空间、非内存空间以及地址空洞

**BaseTmpOfKernelAddr** 临时内核地址的基地址

**OffsetTmpOfKernelFile** 临时内核程序的转存空间。由于内核程序的读取操作是通过BIOS中断服务程序INT 13h实现的，BIOS在实模式下只支持上限为1MB的物理地址空间寻址，所以必须先将内核程序读入到临时转存空间，然后再通过特殊方式搬运到1 MB以上的内存空间中

**MemoryStructBufferAddr** 内存结构缓冲区的地址

#### fat12.inc

fat12.inc 需要自己写，内容如下：

首先创建一个文件：

```bash
vi fat12.inc 
```

内容：

```assembly
BaseOfStack 	equ 0x7c00
BaseOfLoader 	equ 0x1000
OffsetOfLoader 	equ 0x00

RootDirSectors			equ	14
SectorNumOfRootDirStart	equ	19
SectorNumOfFAT1Start	equ	1
SectorBalance			equ	17	

	BS_OEMName 		db 'Mi64boot'
	BPB_BytesPerSec	dw	512
	BPB_SecPerClus	db	1
	BPB_RsvdSecCnt	dw	1
	BPB_NumFATs		db	2
	BPB_RootEntCnt	dw	224
	BPB_TotSec16	dw	2880
	BPB_Media		db	0xf0
	BPB_FATSz16		dw	9
	BPB_SecPerTrk	dw	18
	BPB_NumHeads	dw	2
	BPB_HiddSec		dd	0
	BPB_TotSec32	dd	0
	BS_DrvNum		db	0
	BS_Reserved1	db	0
	BS_BootSig		db	0x29
	BS_VolID		dd	0
	BS_VolLab		db	'boot loader'
	BS_FileSysType	db	'FAT12   '
```



#### Loader引导加载程序（屏幕显示）

之前写过，即显示StartLoaderMessage

添加代码：

```assembly
[SECTION .s16]
[BITS 16]
```

**[SECTION .s16]** 定义了一个名为“.s16”的新代码或数据段。SECTION关键字用于在输出文件中定义不同的段（如代码段、数据段等）

**[BITS 16]** 设置了汇编器应该生成哪种位宽的代码。BITS伪指令可以通知NASM编译器生成的代码，将运行在16位宽的处理器上或者运行在32位宽的处理器上，语法是'BITS 16'或'BITS 32 '

当NASM编译器处于16位宽('BITS 16')状态下，使用32位宽**数据**指令时需要在指令前加入前缀0x66，使用32位宽**地址**指令时需要在指令前加入前缀0x67。而在32位宽（'BITs 32')状态下，使用16位宽指令也需要加入指令前缀。伪指令'BITS位宽’拥有一种等效的书写格式，即 [BITS位宽]。

#### 开启地址A20

##### A20地址线概念

A20地址线（A20 Line）是一个与x86架构计算机系统中的内存寻址有关的硬件信号线。

在实模式下（即16位模式，通常是计算机启动时的模式），x86架构的处理器使用20位地址线，可以寻址从0x00000到0xFFFFF的内存空间，即1MB的内存。然而，由于实模式的段偏移寻址方式，地址空间实际上在到达0xFFFFF后会“回绕”到0x00000。

A20地址线实际上控制着第21位的内存地址。在进入保护模式或其他高级模式之前，通常需要打开或“解禁”A20地址线，以便能够访问超过1MB的内存。

初始状态下，A20线通常是关闭的，这意味着21位地址的第20位总是被设置为0，导致内存地址0x100000（1MB）和0x00000实际上指向同一块物理内存。

**为什么需要打开A20地址线？**

打开A20线是进入保护模式或长模式（在64位系统中）的一个重要步骤，因为在这些模式下，处理器需要访问超过1MB的内存。

**打开方式有哪些？**

A20线可以通过多种方式打开，包括使用键盘控制器（8042芯片）、快速A20门、使用BIOS中断服务INT 15h的主功能号AX=2401开启（AX=2400是禁用，AH=2403是查询当前A20地址线状态）、读0xee端口打开。

书中采用**访问A20快速门**来开启A20功能，即置位0x92端口的第1位。

##### 打开A20地址线

```assembly
push	ax
in	al,	92h
or	al,	00000010b
out	92h,	al
pop	ax

cli

db	0x66
lgdt	[GdtPtr]	

mov	eax,	cr0
or	eax,	1
mov	cr0,	eax

mov	ax,	SelectorData32
mov	fs,	ax
mov	eax,	cr0
and	al,	11111110b
mov	cr0,	eax

sti
```

**in	al,	92h ** 从端口0x92（使用A20快速门）读取一个字节到al

**or	al,	00000010b** 设置al的第1位（如果要开启A20，需要置位0x92端口的第一位）

**cli** 使用指令cLI关闭外部中断，确保在执行关键代码段时不会被外部事件打断

**db	0x66** 这是一个前缀，用于接下来的指令以使其操作32位数据（上文提到：当NASM编译器处于16位宽('BITS 16')状态下，使用32位宽**数据**指令时需要在指令前加入前缀0x66）

**lgdt	[GdtPtr]**  指令LGDT加载保护模式结构数据信息（下文”从实模式进入保护模式再到IA-32e模式“会讲解）

**or	eax,	1**，**mov	cr0,	eax**   置位CRO寄存器的第0位来开启保护模式。

**mov	ax,	SelectorData32**  将数据选择器加载到ax

**mov	eax,	cr0**，**and	al,	11111110b** ，**mov	cr0,	eax** 清除CR0的最低位，禁用保护模式

**sti** 恢复中断

这段代码是为了让FS段寄存器可以在实模式下寻址能力超过1MB，也就是Big Real Mode模式

##### Big Real Mode

Big Real Mode（有时也称为“巨型实模式”或“非官方实模式”）是一种特殊的x86处理器模式。它是实模式（Real Mode）和保护模式（Protected Mode）的混合体，通常用于操作系统的启动过程。

**为什么使用Big Real Mode？**

在Big Real Mode下，处理器大部分运行在实模式（16位模式）中，但是启用了一些保护模式的特性，最常见的是使用32位地址寻址，这样，程序可以使用32位的指令和数据类型，同时也能访问超过1MB的内存空间。

**进入Big Real Mode的步骤**

-   首先，系统进入实模式，通常这是处理器复位后的默认模式
-   打开A20线，以便能访问超过1MB的内存
-   设置合适的段描述符，使其界限（Limit）字段更大，通常设置为4G（0xFFFFFFFF）
-   最后，使用某种方式（通常是通过设置CR0寄存器）来启用32位数据和地址线

一旦进入Big Real Mode，程序就能够使用32位寻址，同时仍然能访问BIOS中断和执行其他需要实模式的操作

这种模式主要用于某些特定的、通常是短暂的操作，如操作系统的引导加载程序。一旦这些操作完成，系统通常会尽快切换到完全的保护模式或长模式，因为不是Intel或AMD官方支持的模式

#### 从FAT12文件系统中搜索出kernel.bin（内核程序文件）

代码与Boot引导程序类似

```assembly
mov	word	[SectorNo],	SectorNumOfRootDirStart

Lable_Search_In_Root_Dir_Begin:
	cmp	word	[RootDirSizeForLoop],	0
	jz	Label_No_LoaderBin
	dec	word	[RootDirSizeForLoop]	
	mov	ax,	00h
	mov	es,	ax
	mov	bx,	8000h
	mov	ax,	[SectorNo]
	mov	cl,	1
	call	Func_ReadOneSector
	mov	si,	KernelFileName
	mov	di,	8000h
	cld
	mov	dx,	10h
	
Label_No_LoaderBin:
	mov	ax,	1301h
	mov	bx,	008Ch
	mov	dx,	0300h		;row 3
	mov	cx,	21
	push	ax
	mov	ax,	ds
	mov	es,	ax
	pop	ax
	mov	bp,	NoLoaderMessage
	int	10h
	jmp	$
```

#### 搜索到后读取数据至物理内存

**Label_FileName_Found** ，**Label_Go_On_Loading_File**  与Boot的几乎一致省略，记得将代码中的Func_ReadOneSector、Label_Go_On_Reading、Func_GetFATEntry、Label_Even、Label_Even_2从boot.asm中复制过来

```assembly
push	cx
push	eax
push	fs
push	edi
push	ds
push	esi

mov	cx,	200h
mov	ax,	BaseOfKernelFile
mov	fs,	ax
mov	edi,	dword	[OffsetOfKernelFileCount]

mov	ax,	BaseTmpOfKernelAddr
mov	ds,	ax
mov	esi,	OffsetTmpOfKernelFile
```

**mov	cx,	200h** 设置计数器512，一个扇区的大小

**mov	ax,	BaseOfKernelFile** ，**mov	fs,	ax**  将fs段寄存器设置为内核文件的基地址。这通常用于指定内存中的目标区域，BaseOfKernelFile，内核文件的基地址

**mov	edi,	dword	[OffsetOfKernelFileCount]** 设置为内核文件的偏移计数器的当前值，**edi 通常用作目标地址的指针**。OffsetOfKernelFileCount = OffsetOfKernelFile，为内核文件的偏移地址

**mov	ax,	BaseTmpOfKernelAddr** ，**mov	ds,	ax** 将ds 段寄存器设置为临时内核地址的基地址。这通常用于指定内存中的源区域

**mov	esi,	OffsetTmpOfKernelFile**  将esi 寄存器设置为临时内核文件的偏移地址。**esi 通常用作源地址的指针**

```assembly
Label_Mov_Kernel:
	mov	al,	byte	[ds:esi]
	mov	byte	[fs:edi],	al

	inc	esi
	inc	edi

	loop	Label_Mov_Kernel

	mov	eax,	0x1000
	mov	ds,	eax   

	mov	dword	[OffsetOfKernelFileCount],	edi

	pop	esi
	pop	ds
	pop	edi
	pop	fs
	pop	eax
	pop	cx
```

**mov	al,	byte	[ds:esi]**  从数据段ds 和偏移esi 组成的地址处读取一个字节，并将其存储在al 寄存器中。一个字节一个字节读取，为了避免转存环节发生错误

**mov	byte	[fs:edi],	al**  将al 中的字节写入目标地址，即之前写到的1MB以上的物理内存空间

**inc	esi** ，**inc	edi**  源地址和目标地址都递增 1

**loop	Label_Mov_Kernel**  循环。一个字节一个字节的复制，可以借助汇编指令LOOP可完成

**mov	eax,	0x1000** 可能是内核被加载到的物理或虚拟地址的起始点

**mov	dword	[OffsetOfKernelFileCount],	edi**  由于内核体积庞大必须逐个簇地读取和转存，那么每次转存内核程序片段必须保存目标移值，该值（EDI寄存器）保存于临时变量offsetofKernelFileCount中

#### 显示一个字符’G‘

可以隔离内核程序的加载过程，引入了一种高效的字符显示方法

```assembly
Label_File_Loaded:
	mov	ax, 0B800h
	mov	gs, ax
	mov	ah, 0Fh				
	mov	al, 'G'
	mov	[gs:((80 * 0 + 39) * 2)], ax	
```

**mov	ah, 0Fh**  白色字体，黑色背景

**mov	[gs:((80 * 0 + 39) * 2)], ax**  将 ax 的值（其中包括字符和属性）写入到视频内存的特定位置。

**为什么是*2？**

在文本模式下，每个屏幕上的字符位置由两个字节表示：一个字节用于字符本身（ASCII 码），另一个字节用于字符的属性（如颜色等）。因此，每个字符实际上占用了两个字节的空间。

该方法与BIOS的INT10h中断服务程序相比，更符合操作显卡内存的习惯。从内存地址0B800h开始，是一段专门用于显示字符的内存空间，每个字符占用两个字节的内存空间，其中低字节保存显示的字符，高字节保存字符的颜色属性。

在文本模式下，屏幕通常有 80 列和 25 行。每个字符使用一个字（16位）来表示，其中8位用于字符本身，另外8位用于属性。因此，“((80 * 0 + 39) * 2) ”计算的是第0行、第39列字符的位置（以字节为单位）

![G显示](https://raw.githubusercontent.com/Enid1107/TyporaImgBed/main/Img/202309301627235.png)

#### 关闭软驱马达

```assembly
KillMotor:
	push	dx
	mov	dx,	03F2h
	mov	al,	0	
	out	dx,	al
	pop	dx
```

**mov	dx,	03F2h**  向I/O端口3F2h写入控制命令实现关闭软驱马达

软盘驱动器控制表：

![软盘驱动器控制表](../../MicroHex64/%E5%9B%BE%E7%89%87/%E8%BD%AF%E7%9B%98%E9%A9%B1%E5%8A%A8%E5%99%A8%E6%8E%A7%E5%88%B6%E8%A1%A8.png)

#### 物理地址空间信息的获取

##### 显示信息 

```assembly
StartGetMemStructMessage:	db	"Start Get Memory Struct."
GetMemStructErrMessage:	db	"Get Memory Struct ERROR"
GetMemStructOKMessage:	db	"Get Memory Struct SUCCESSFUL!"
```

##### 屏幕显示

```assembly
mov	ax,	1301h
mov	bx,	000Fh
mov	dx,	0400h		
mov	cx,	24
push	ax
mov	ax,	ds
mov	es,	ax
pop	ax
mov	bp,	StartGetMemStructMessage
int	10h

mov	ebx,	0
mov	ax,	0x00
mov	es,	ax
mov	di,	MemoryStructBufferAddr	
```

**mov	ax,	1301h**  BIOS中断服务INT 10 ，当AH=13h 为写字符串

**MemoryStructBufferAddr**  内存结构缓冲区的地址

##### 获取系统内存的结构信息

```assembly
Label_Get_Mem_Struct:
	mov	eax,	0x0E820
	mov	ecx,	20
	mov	edx,	0x534D4150
	int	15h
	jc	Label_Get_Mem_Fail
	add	di,	20

	cmp	ebx,	0
	jne	Label_Get_Mem_Struct
	jmp	Label_Get_Mem_OK
```

**mov	eax,	0x0E820**  BIOS中断服务INT 15，AX = E820h查询系统地址映射，获取内存映射

**mov	ecx,	20**  设置ecx 寄存器为20（0x14），这通常表示返回的内存范围结构的大小

**mov	edx,	0x534D4150**  设置edx 寄存器为0x534D4150 ，这是ASCII字符"SMAP"的十六进制表示，用作一个签名来确认这个功能

**为什么需要签名？** 

这主要是为了验证和确保正在执行正确的操作或功能。这个特定的签名在功能调用前设置，并在调用后检查。如果在功能调用返回后 EDX 仍然是"SMAP"，这通常意味着 BIOS 支持这个子功能，并且成功地返回了有效的内存映射信息。

注意：这个签名是固定的

**jc	Label_Get_Mem_Fail**  检查CF（进位标志），CF被设置（表示出错），则跳转

**add	di,	20**  如果操作成功，di 寄存器（目标索引）加上20，以便将下一个内存范围结构存放到内存中

**cmp	ebx,	0**  检查ebx 寄存器是否为0。在E820的情境下，ebx 为0表示没有更多的内存范围信息

**jne** 跳转如果不等于

##### 获取失败、获取成功

与屏幕打印一样，没有特别更改

#### 显示查询结果信息

该显示以16进制形式显示

**为什么以16进制形式显示？**

-   简洁性: 16进制能以更简洁的形式表示较长的二进制数
-   可读性: 相比长串的二进制数字，16进制更易于阅读和理解
-   易于调试和诊断: 在硬件和底层软件调试中，直接查看16进制表示通常会更加直观
-   与字节对齐: 一个字节（8位）可以用两个16进制数字表示（每个16进制数字对应4位），这样方便与实际硬件和内存结构对齐

##### 临时值

```assembly
DisplayPosition		dd	0
```

##### 显示

```assembly
Label_DispAL:
	push	ecx
	push	edx
	push	edi
	
	mov	edi,	[DisplayPosition]
	mov	ah,	0Fh
	mov	dl,	al
	shr	al,	4
	mov	ecx,	2
	
.begin:
	and	al,	0Fh
	cmp	al,	9
	ja	.1
	add	al,	'0'
	jmp	.2
.1:

	sub	al,	0Ah
	add	al,	'A'
.2:

	mov	[gs:edi],	ax
	add	edi,	2
	
	mov	al,	dl
	loop	.begin

	mov	[DisplayPosition],	edi

	pop	edi
	pop	edx
	pop	ecx
	
	ret
```

**shr	al,	4**  将al 右移4位，这样我们可以得到 al 的高4位（以十六进制形式显示这个数值时，你需要分别处理它的高 4 位和低 4 ）

**mov	ecx,	2**  设置循环计数为2，因为我们要显示两个十六进制数字

**.begin**  这个循环将al 的当前值（首次循环时是高4位，第二次是低4位）转换为ASCII字符并显示

**and	al,	0Fh**  保留 al 的低4位

**cmp	al,	9** ，**ja	.1** 如果`al`的值大于9，那么它是一个字母（A-F）。ja指令用于无符号数比较

**add	al,	'0'**  将 al 的值转换为其ASCII表示（1-9的转换）

**sub	al,	0Ah** ，**add	al,	'A'**  将 al 的值转换为其ASCII表示（‘A’-‘Z’的转换）

**mov	[gs:edi],	ax**  将ax寄存器的内容（其中al 是字符，ah 是属性）写入到由 gs 和 edi 指定的内存地址。 gs 一般指向视频内存的段， edi 是偏移量

**add	edi,	2**  移动到屏幕的下一个字符位置

**mov	[DisplayPosition],	edi**  更新DisplayPosition 的值以指向屏幕上的新位置

#### SVGA芯片与VBE显示

**什么是VBE显示模式？**

VESA BIOS Extensions（VBE）是一组用于统一视频显示控制器（也称为显卡或视频卡）的界面规范。VBE定义了一系列用于查询和设置图形模式、获得显卡信息等的函数，从而使软件开发人员能够以一种与硬件无关的方式编程

"显示模式"通常指的是一组特定的视频输出参数：

-   分辨率
-   颜色深度：每个像素用多少位来表示，如8位、16位、24位、32位等
-   刷新率：屏幕每秒更新多少次
-   内存布局：图像数据在视频内存中如何组织

**什么是SVGA芯片？**

SVGA（Super Video Graphics Array）是一种图形显示标准，比原始的VGA（Video Graphics Array）标准提供了更高的分辨率和更多的颜色选项。SVGA不是一种单一的技术或产品，而是一组硬件和软件规范，用于图形显示。

当我们提到SVGA芯片时，通常指的是嵌入在显卡上的一种或多种集成电路（IC），这些电路负责处理计算机生成的图像数据，并将其转换为可以在监视器上显示的信号。SVGA芯片通常包含一定量的图形内存、数学协处理器和其他逻辑电路，用于执行如位图绘制、三维渲染和视频解码等任务。

**注：**对于SVGA芯片信息和SVGA模式获取，书中没有明确指出，查询了作者给出的loader.asm做出以下补充

##### 获取SVGA芯片信息

```assembly
mov	ax,	1301h
mov	bx,	000Fh
mov	dx,	0800h		
mov	cx,	23
push	ax
mov	ax,	ds
mov	es,	ax
pop	ax
mov	bp,	StartGetSVGAVBEInfoMessage
int	10h

mov	ax,	0x00
mov	es,	ax
mov	di,	0x8000
mov	ax,	4F00h

int	10h

cmp	ax,	004Fh

jz	.KO
```

开头是显示开始获取信息，并打印在屏幕上

**mov	ax,	0x00** ，**mov	es,	ax** ，**mov	di,	0x8000** 这里设置 es:di 为0x8000，这通常是存储从int 10h 返回的VBE信息的内存地址

**mov	ax,	4F00h** 设置 ax 寄存器为 4F00h，这是查询VBE信息的功能号

**cmp	ax,	004Fh** 检查ax 是否为 004Fh ，这会表明VBE调用是否成功

##### 获取SVGA芯片信息失败

```assembly
mov	ax,	1301h
mov	bx,	008Ch
mov	dx,	0900h		
mov	cx,	23
push	ax
mov	ax,	ds
mov	es,	ax
pop	ax
mov	bp,	GetSVGAVBEInfoErrMessage
int	10h

jmp	$
```



##### 获取SVGA芯片信息成功

```assembly
.KO:

	mov	ax,	1301h
	mov	bx,	000Fh
	mov	dx,	0A00h		
	mov	cx,	29
	push	ax
	mov	ax,	ds
	mov	es,	ax
	pop	ax
	mov	bp,	GetSVGAVBEInfoOKMessage
	int	10h
```



##### 获取SVGA模式信息

```assembly
Label_SVGA_Mode_Info_Get:

	mov	cx,	word	[es:esi]
;显示SVGA模式信息
	push	ax
	
	mov	ax,	00h
	mov	al,	ch
	call	Label_DispAL

	mov	ax,	00h
	mov	al,	cl	
	call	Label_DispAL
	
	pop	ax

;遍历和获取SVGA模式信息
	cmp	cx,	0FFFFh
	jz	Label_SVGA_Mode_Info_Finish

	mov	ax,	4F01h
	int	10h

	cmp	ax,	004Fh

	jnz	Label_SVGA_Mode_Info_FAIL	

	add	esi,	2
	add	edi,	0x100

	jmp	Label_SVGA_Mode_Info_Get
```

##### 获取SVGA模式信息失败

```assembly
Label_SVGA_Mode_Info_FAIL:

	mov	ax,	1301h
	mov	bx,	008Ch
	mov	dx,	0D00h		
	mov	cx,	24
	push	ax
	mov	ax,	ds
	mov	es,	ax
	pop	ax
	mov	bp,	GetSVGAModeInfoErrMessage
	int	10h
```

##### 获取SVGA模式信息结束（成功）

```assembly
Label_SVGA_Mode_Info_Finish:
	mov	ax,	1301h
	mov	bx,	000Fh
	mov	dx,	0E00h		
	mov	cx,	30
	push	ax
	mov	ax,	ds
	mov	es,	ax
	pop	ax
	mov	bp,	GetSVGAModeInfoOKMessage
	int	10h
```

##### 配置芯片的显示模式

```assembly
mov	ax,	4F02h
mov	bx,	4180h	
int 	10h

cmp	ax,	004Fh
jnz	Label_SET_SVGA_Mode_VESA_VBE_FAIL
```

**mov	ax,	4F02h**  设置ax 为4F02h ，这是VESA BIOS Extensions（VBE）用于设置图形模式的功能号

**mov	bx,	4180h**  mode：0x180 or 0x143

我的用4180h分辨率过高了，改用了4143h

显示模式号的具体信息：

![显示模式号的具体信息](../../MicroHex64/%E5%9B%BE%E7%89%87/%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F%E5%8F%B7%E7%9A%84%E5%85%B7%E4%BD%93%E4%BF%A1%E6%81%AF.png)

**cmp	ax,	004Fh** 检查 ax 的值是否为 004Fh，以判断视频模式是否设置成功（执行 INT 10 后，ax 通常会被设置为 004Fh 如果操作成功，或者其它值如果操作失败）

此部分内容是关于VBE ( VESABIOSEXTENSION)的显示模式，通过设置不同的显示模式号，可配置出不同的屏幕分辨率、每个像素点的数据位宽、颜色格式等。这些信息皆是从Bochs虚拟平台的SVGA芯片中获得

### 从实模式进入保护模式再到IA-32e模式

**什么是实模式，什么是保护模式？**

实模式和保护模式是x86架构CPU的两种不同的运行模式

实模式：

-   所有x86兼容处理器在启动时的默认模式
-   简单，但功能受限。它只能访问1MB的内存
-   在实模式下，没有内存保护、多任务支持或其他高级特性
-   地址转换是线性的，即逻辑地址直接转换为物理地址，不经过任何复杂的转换
-   通常在早期的个人电脑以及用于引导操作系统的启动阶段使用

保护模式：

-   提供了对高达4GB内存的访问
-   支持内存分段和分页，以及硬件级的内存保护
-   可以运行多个任务，并且提供了硬件支持以保障任务之间不会相互干扰
-   支持特权级别，这允许操作系统更有效地控制对硬件资源的访问
-   通常在现代操作系统（如Windows, Linux等）中使用

在保护模式里，处理器按程序的执行级别分为0、1、2、3四个等级（由高到低排序)。最高等级0由系统内核使用，最低等级3由应用程序使用，Linux内核目前仅使用这两个等级（0级和3级)。而等级1和等级2介于内核程序与应用程序之间，它们通常作为系统服务程序来使用。虽然层级划分的决定。

**如何从实模式进入保护模式？**

步骤简述：

1、初始化全局描述符表（GDT）：在内存中创建一个全局描述符表（GDT），并填充代码段和数据段的描述符。

2、加载GDT到GDTR寄存器：使用lgdt 指令将GDT的基地址和限制加载到GDTR寄存器。

3、禁用中断：使用cli 指令来禁用硬件中断，以确保在模式切换期间不会发生中断

4、设置CR0寄存器的PE位：CR0寄存器的第0位（PE，保护使能）用于控制CPU是运行在实模式还是保护模式。将这一位设置为1即可激活保护模式（**进入保护模式的契机**）

5、跳转到保护模式代码段：一旦PE位设置为1，接下来的指令应当是一个长跳转（far jump），以便清空流水线并开始执行保护模式下的代码

6、设置其它段寄存器：切换到保护模式后，段寄存器（如DS，SS，ES等）需要重新设置，以使用在GDT中定义的新的段描述符

7、（可选）打开分页：如果你打算使用内存分页，此时可以配置页表并设置CR0的PG（分页）位。

8、启用中断：如果一切配置正确，你现在可以使用 sti 指令重新启用硬件中断

**什么是GDT？**

全局描述符表（GDT，Global Descriptor Table）是用于保护模式下的x86和x86-64架构中的一种数据结构。GDT用于定义不同的内存段，每个段有自己的属性，例如访问权限、段的大小、段的类型等。操作系统和应用程序通过这些段描述符来访问物理或虚拟内存。

**GDT的主要用途？**

-   内存保护：通过为不同的任务或程序设定不同的段，GDT有助于防止一个任务意外（或恶意地）访问或修改其他任务的内存。
-   权限控制：段描述符包含有关谁可以访问该段以及如何访问的信息（例如，只读、可写等）
-   代码和数据隔离：可以创建专用的代码段和数据段，以保证它们的独立性和保护
-   系统任务切换：GDT也用于支持硬件级的任务切换机制，尽管现代操作系统通常使用软件级的任务切换
-   分段到分页的过渡：在某些系统设计中，GDT被用作从实模式（无分段、无分页的内存管理）转换到保护模式（有分段和分页）
-   64位模式支持：在x86-64架构中，GDT通常用于从32位保护模式过渡到64位长模式

#### 切换至保护模式而准备的系统数据结构

```assembly
[SECTION gdt]

LABEL_GDT:		dd	0,0
LABEL_DESC_CODE32:	dd	0x0000FFFF,0x00CF9A00
LABEL_DESC_DATA32:	dd	0x0000FFFF,0x00CF9200

GdtLen	equ	$ - LABEL_GDT
GdtPtr	dw	GdtLen - 1
	dd	LABEL_GDT

SelectorCode32	equ	LABEL_DESC_CODE32 - LABEL_GDT
SelectorData32	equ	LABEL_DESC_DATA32 - LABEL_GDT
```

**LABEL_GDT:		dd	0,0**   GDT 的第一个条目通常是一个空描述符，这里用两个双字（double word, dd）0来填充

**LABEL_DESC_CODE32:	dd	0x0000FFFF,0x00CF9A00**  定义了一个从基地址0开始，大小为64KB的32位代码段，这个段是可读的，并且已经被访问。FFFF  代表段的限制，说明这是一个 64KB 大小的段。00CF 是段的属性字段，C表示段的大小是4KB（描述符粒度（G）为1），F表示32位代码段。9A 是段的访问权限和类型，9 表示这是一个代码段，A表示段是可读的，并且已被访问（2表示该段是可写的，并且已经被访问）。

**什么是描述符粒度（G）？**

描述符的粒度（Granularity）位是用来确定段描述符如何解释段界限（Limit）字段的。在x86体系结构中，段描述符通常包含一个段界限字段和一个粒度位。

描述符的粒度（G）位位于描述符的最后一个字节（也就是第8个字节）的最高位（第7位，从0开始数）。

**为什么可以寻址4GB空间？**

像上面所说， 0xCF  字节中，二进制表示为 11001111，可以看出，第7位（从0开始数）是1，这表示粒度（G）位是设置的。

而在保护模式下，如果描述符的G（粒度）位设置为1，这个界限会被解释为以4KB页为单位，因此 0xFFFF 实际上表示的是 0xFFFF * 4KB = 4GB - 1。

**GdtLen	equ	$ - LABEL_GDT**   计算 GDT 的长度。$ 是当前地址，LABEL_GDT 是 GDT 开始的地址。两者之差就是 GDT 的长度

**GdtPtr	dw	GdtLen - 1** 定义 GDT 指针的长度字段。GDT 的长度通常是实际长度减一

**dd	LABEL_GDT** 这是 GDT 指针的地址字段，指向 GDT 的起始地址

**SelectorCode32	equ	LABEL_DESC_CODE32 - LABEL_GDT**  计算32位代码段选择器的偏移量。它是代码段描述符在 GDT 中的地址与 GDT 起始地址的差

**SelectorData32	equ	LABEL_DESC_DATA32 - LABEL_GDT** 计算32位数据段选择器的偏移量

#### 内存空间申请

```assembly
IDT:
	times	0x50	dq	0
IDT_END:

IDT_POINTER:
		dw	IDT_END - IDT - 1
		dd	IDT
```

**IDT:times	0x50	dq	0**   这行代码创建了一个名为IDT 的空间，用来存储中断描述符。该空间初始化为0，并且有0x50（即80）个这样的8字节描述符，总大小是0x50 * 8 = 0x280 字节

**IDT_POINTER** 部分定义了一个IDT指针，该指针通常用于lidt 指令

**dw	IDT_END - IDT - 1**  这里计算IDT的长度（以字节为单位）并减去1。这个值会存储在IDT指针的第一个字（word）

**dd	IDT**  IDT表的起始地址，会存储在IDT指针的接下来的四个字节（double word）

**什么是中断描述符表？**

中断描述符表（IDT, Interrupt Descriptor Table）是一个在x86和x86-64体系结构中用于处理硬件中断和软件异常的数据结构。当CPU接收到一个中断或异常时，它会使用IDT中的相关信息来找到适当的处理程序（handler）并执行。

IDT是一个包含多个中断描述符（Interrupt Descriptors）的表。每个描述符都包含了处理该中断或异常所需的信息，如处理程序的入口地址、代码段选择子（Code Segment Selector）等。

在保护模式下，使用lidt 指令来加载IDT的基础地址和限制到特殊的寄存器。这样，当中断或异常发生时，CPU就知道去哪里查找相关的处理程序。在实模式下，也有一个相似但更简单的机制。

在处理器切换至保护模式前，引导加载程序已使用cLI指令禁止外部中断，所以在切换到保护模式的过程中不会产生中断和异常，进而不必完整地初始化IDT，只要有相应的结构体即可。如果能够保证处理器在模式切换的过程中不会产生异常，即使没有IDT也可以。

#### 从实模式切换到保护模式

初始化IDT GDT 进入保护模式：

```assembly
	cli			

	db	0x66
	lgdt	[GdtPtr]


	mov	eax,	cr0
	or	eax,	1
	mov	cr0,	eax	

	jmp	dword SelectorCode32:GO_TO_TMP_Protect
```

**db	0x66** 操作前缀，用于指示接下来的指令应以32位操作数执行

**lgdt	[GdtPtr]** 加载全局描述符表的地址到GDTR寄存器

**mov	eax,	cr0** 将控制寄存器 CR0 的当前值加载到 EAX 寄存器中

**or	eax,	1**   设置 CR0 的最低位为1，用于启动保护模式

**mov	cr0,	eax** 将修改后的值写回 CR0 寄存器，实际开启保护模式

**jmp	dword SelectorCode32:GO_TO_TMP_Protect**  跳转到保护模式下的代码段

然后查找一下当前寄存段信息

![img](https://raw.githubusercontent.com/Enid1107/TyporaImgBed/main/Img/202309261030001.png)

在上述段寄存器信息里，CS段寄存器中的段基地址base、段限长limit以及其他段属性，自汇编代码jmpdwordSelectorCode32:Go_To_TMP_Protect执行后皆发生了改变。与此同时，GDTR寄存器中的数据已更新为cdtPtr结构记录的GDT表基地址和长度。

再使用info flags命令查看EFLAGS标志寄存器的PF标志位：

![PF标志位](../../MicroHex64/%E5%9B%BE%E7%89%87/PF%E6%A0%87%E5%BF%97%E4%BD%8D.png)

PF标志位已被置位（大写字母)

![进入保护模式](https://raw.githubusercontent.com/Enid1107/TyporaImgBed/main/Img/202309301630869.png)

已经进入保护模式

### 从保护模式进入IA-32e模式

**什么是IA-32e模式？**

IA-32e模式（也称为长模式）是Intel 64和AMD64（通常称为x86-64）架构中的一种运行模式。这一模式提供了对64位处理器功能的全面支持，包括64位地址空间和64位数据计算。IA-32e模式是与32位IA-32架构（x86）向后兼容的，这意味着大多数32位应用程序和操作系统可以在64位模式下运行，虽然可能需要一些修改。

IA-32e的两个子模式：

-   兼容模式：这个模式允许运行在保护模式下编译的32位代码（与IA-32架构保护模式下的代码相同）。这样做主要是为了向后兼容
-   64位模式：这是一个全新的模式，支持64位地址和数据，以及一些新的指令。64位模式下的操作系统可以运行32位和64位的应用程序，尽管32位程序通常运行在兼容模式下。

IA-32e模式的优点：

-   更大的地址空间：最多可以支持18.4 million TB（约18.4百万兆字节）的虚拟地址空间。
-   更多的通用寄存器：增加了额外的通用寄存器，并将所有通用寄存器扩展到64位。
-   更多的SIMD（单指令多数据）支持：对多媒体和科学计算等应用有优势。

**如何从保护模式进入IA-32e模式？**

1、检查CPU支持：首先，确保CPU支持64位模式。这通常可以通过检查CPUID指令的某些标志来完成

2、进入保护模式：如果还没有进入保护模式，需要首先进入保护模式

3、禁用分页：如果分页已经启用，则需要先禁用它

4、设置EFER寄存器：使用 MSR（Model Specific Registers）来设置 EFER.LME（Long Mode Enable）位

5、启用分页：启用分页系统，并确保使用支持64位的分页结构（通常是4级分页）

6、设置CR3：将CR3寄存器设置为新的PML4（Page-Map Level 4）表的物理地址

7、设置CR4：将CR4的 PAE（Physical Address Extension）位设置为1

8、设置CR0：将CR0的 PG（Paging）位设置为1，以启用分页

9、远跳或远调用： 执行一个远跳或远调用到一个64位代码段，以便从保护模式切换到长模式

10、设置64位代码段和栈：确保你现在在一个合适的64位代码和数据段中运行，并设置一个64位栈

11、代码转换：此时，你应该能够执行64位代码

**注意：** 

-   数据结构：由于保护模式的描述符表基地址是32位，这使得它们均位于低4GB线性地址空间内。既然已经开启IA-32e模式，那么系统各描述符表寄存器理应（**必须**）重新加载（借助LGDT、LLDT、LIDT和LTR指令）为IA-32e模式的64位描述符表。
-   中断和异常：当软件激活IA-32e模式后，中断描述符表寄存器IDTR仍然使用保护模式的中断描述符表,那么在将IDTR寄存器更新为64位中断描述符表IDT前不要触发中断和异常，否则处理器会把32位兼容模式的中断门解释为64位中断门

#### 临时GDT表数据结构

```assembly
[SECTION gdt64]

LABEL_GDT64:		dq	0x0000000000000000
LABEL_DESC_CODE64:	dq	0x0020980000000000
LABEL_DESC_DATA64:	dq	0x0000920000000000

GdtLen64	equ	$ - LABEL_GDT64
GdtPtr64	dw	GdtLen64 - 1
		dd	LABEL_GDT64

SelectorCode64	equ	LABEL_DESC_CODE64 - LABEL_GDT64
SelectorData64	equ	LABEL_DESC_DATA64 - LABEL_GDT64
```

**LABEL_GDT64:		dq	0x0000000000000000** 所有位都是0

**LABEL_DESC_CODE64:	dq	0x0020980000000000** 代码段描述符。第43-52位（从最低有效位开始数）是 0x2098 ，表示代码段的属性（P=1, L=1, DPL=00, Type=1010）。64位描述符的高32位用于存储段限制、基地址等，但在64位模式下，很多这些字段不再有用或者意义发生了变化。因此，高32位通常都是0。

**LABEL_DESC_DATA64:	dq	0x0000920000000000**  数据段描述符。第43-52位是 0x92 ，表示数据段的属性（P=1, DPL=00, Type=0010）

**什么是43-52位？**

在Intel x86架构中，段描述符通常是64位（8字节）或者在某些模式下是128位的。这些位分为多个字段，用于描述段的各种属性。位43-52是属性字段，其中包括了段的类型、特权级别、是否存在等信息。从最低位（LSB）到最高位（MSB）。

-   Type（4位，表示段类型），第8到第11位
-   S（1位，描述符类型），第12位
-   DPL（2位，特权级别），第13和第14位
-   P（1位，段存在），第15位

以 0x2098举例：

 0x2098 = 0010 0000 1001 1000

![20230903152007](https://raw.githubusercontent.com/Enid1107/TyporaImgBed/main/Img/202309031520123.png)

Type为1010，表示这是一个可读的代码段

S为1，表示这是一个代码或数据描述符，而不是系统描述符

DPL为00，，表示这个段是特权级别0（也就是最高特权级别）

P为1，表示这个段是存在的（也就是在内存中）

**GdtLen64	equ	$ - LABEL_GDT64**   使用汇编的$ 操作符获取当前地址与GDT起始地址（LABEL_GDT64）之间的偏移量，以计算GDT的长度

**GdtPtr64	dw	GdtLen64 - 1** GDT的长度（GdtLen64 - 1）

**dd	LABEL_GDT64** GDT的线性地址

**SelectorCode64** 代码段选择器的偏移量

**SelectorData64** 数据段选择器的偏移量

**为什么LABREL_GDT是dd 0,0 ，而LABEL_GDT64是dq	0x0000000000000000？**

在IA-32架构（也就是32位模式）下，全局描述符表（GDT）中的每个描述符通常是64位（8字节）的。在这种情况下，通常使用两个32位（4字节）的数据定义（dd）来表示一个64位描述符。所以dd 0, 0实际上是创建了一个64位（8字节）的空描述符。

在64位模式（也称为IA-32e模式）下，全局描述符表（GDT）的描述符通常是16字节（128位）。然而，在实际应用中，高64位通常不使用，保持为0。因此，对于64位模式的描述符，dq 0x0000000000000000 是用来定义一个128位描述符的低64位，高64位默认为0。

总的来说dd 0, 0 用于32位模式，而dq 0x0000000000000000 用于64位模式

#### IA-32e模式的切换程序

```assembly
[SECTION .s32]
[BITS 32]

GO_TO_TMP_Protect:
	mov	ax,	0x10
	mov	ds,	ax
	mov	es,	ax
	mov	fs,	ax
	mov	ss,	ax
	mov	esp,	7E00h

	call	support_long_mode
	test	eax,	eax

	jz	no_support
```

**[BITS 32]** 设置环境为32位保护模式，以便稍后可以更平滑地过渡到64位模式。

**mov	esp,	7E00h** 将栈指针（ESP）设置为 0x7E00

**test	eax,	eax** 测试 eax寄存器的值。如果eax 为0，ZF（零标志）将被设置

**jz	no_support** 如果ZF标志被设置（也就是说，如果eax 为0），则跳转到标签no_support ，表明CPU不支持长模式

#### 检测是否支持IA-32e模式

```assembly
support_long_mode:
	mov	eax,	0x80000000
	cpuid
	cmp	eax,	0x80000001
	setnb	al	
	jb	support_long_mode_done
	mov	eax,	0x80000001
	cpuid
	bt	edx,	29
	setc	al
	
support_long_mode_done:
	movzx	eax,	al
	ret

no_support:
	jmp	$
```

**mov	eax,	0x80000000**  设置eax 寄存器为0x80000000，准备执行CPUID 指令。CPUID 用 eax 寄存器的值来确定应提供哪种信息

CPUID汇编指令的扩展功能项0x80000001的第29位，指示处理器是否支持IA-32e模式，只有当CPUID指令的扩展功能号大于等于0x80000001时，才有可能支持64位的长模式,

**cpuid** 执行 CPUID 指令，返回CPU信息。这里用来获取支持的最大扩展功能编号

**mov	eax,	0x80000001** : 检查eax 是否大于或等于0x80000001，如果是，则CPU支持至少一些扩展功能，包括长模式支持的检查。

**setnb	al** 如果上一步的比较为真（即eax >= 0x80000001），则将 al 设置为1。

**bt	edx,	29**  测试EDX 寄存器的第29位。这一位用于标识CPU是否支持长模式

**setc	al** 如果第29位为1（支持长模式），则设置al 为1

**mov与movzx的区别？**

mov，简单地将源操作数的值移动到目标操作数。它不会改变其他位。movzx，将源操作数的值移动到目标操作数，并将目标操作数的高位清零（即进行零扩展）。

**setnb与setc的区别？** 

setnb，如果进位标志（CF）为0，则将目标字节设置为1；否则设置为0。setc，如果进位标志（CF）为1，则将目标字节设置为1；否则设置为0。

#### 页目录项和页表项的配置

```assembly
mov	dword	[0x90000],	0x91007
mov	dword	[0x90800],	0x91007		

mov	dword	[0x91000],	0x92007

mov	dword	[0x92000],	0x000083

mov	dword	[0x92008],	0x200083

mov	dword	[0x92010],	0x400083

mov	dword	[0x92018],	0x600083

mov	dword	[0x92020],	0x800083

mov	dword	[0x92028],	0xa00083
```

这段程序将IA-32e模式的页目录首地址设置在ox90000地址处，并相继配置各级页表项的值(该值由页表起始地址和页属性组成)。关于页表属性的描述请参见**第6章**分页机制的内容。

#### 重新加载GDT初始化大部分寄存器

```assembly
db	0x66
lgdt	[GdtPtr64]
mov	ax,	0x10
mov	ds,	ax
mov	es,	ax
mov	fs,	ax
mov	gs,	ax
mov	ss,	ax

mov	esp,	7E00h
```

#### 开启物理地址拓展功能

```assembly
mov	eax,	cr4
bts	eax,	5
mov	cr4,	eax
```

CR4控制寄存器的第5位是PAE功能的标志位，置位该标志位可开启PAE。

**bts	eax,	5** 设置 eax 中第5位（从0开始计数）为1。处理器启用PAE模式，允许使用更大的物理地址空间。

#### CR3的设置

```assembly
mov	eax,	0x90000
mov	cr3,	eax
```

当页目录基地址已加载到CR3控制寄存器，接下来就可通过置位IA32_EFER寄存器的LME标志位激活IA-32e模式

#### 置位IA32_EFER寄存器的LME标志位激活IA-32e模式

```assembly
mov	ecx,	0C0000080h		
rdmsr

bts	eax,	8
wrmsr
```

**mov	ecx,	0C0000080h** 设置 ecx 为 IA32_EFER 的地址

**rdmsr** 读取IA32_EFER 到eax

**bts	eax,	8** 设置eax 中的第8位（从0开始计数）为1，启用长模式

**wrmsr** 将eax 和 edx 的值写回 IA32_EFER

#### 开启保护模式和分页

```assembly
mov	eax,	cr0
bts	eax,	0
bts	eax,	31
mov	cr0,	eax

jmp	SelectorCode64:OffsetOfKernelFile
```

**bts	eax,	0** 设置eax 的第0位为1，启用保护模式

**bts	eax,	31** 设置eax 的第31位为1。第31位是PG（Paging Enable）位，设置该位会启用分页。

**jmp	SelectorCode64:OffsetOfKernelFile** 代码转换到64位模式

### 从Loader跳转到内核程序

此刻仅需一条远跳转/调用指令，便可切换到IA-32e模式。

```assembly
jmp SelectorCode64 :OffsetOfKernelFile
```

开启Bochs虚拟机，使用b命令在物理地址0x10000o处设置一个断点，然后再使用c命令运行虚拟机。当处理器进入IA-32e模式，进而跳转至地址0x100000处执行内核程序

![设置断点0x100000](https://raw.githubusercontent.com/Enid1107/TyporaImgBed/main/Img/202309301635057.png)

q退出虚拟机，发现进入64位

![进入64位](https://raw.githubusercontent.com/Enid1107/TyporaImgBed/main/Img/202309301637266.png)