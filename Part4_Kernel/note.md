改用AT&T格式

# 内核执行头文件

## 什么是内核执行头程序

内核执行头程序，其实是内核程序中的一小段汇编代码。当Loader引导加载程序移交控制权后，处理器便会执行Kernel内核程序的这段代码。内核执行头程序负责为操作系统创建段结构和页表结构、设置某些结构的默认处理函数、配置关键寄存器等工作。

BootLoader引导启动程序占用了0~1 MB的物理地址空间，而内核程序将使用1 MB以上的物理地址空间。

### 内核程序的链接脚本

#### kernel.lds

链接器会按照链接脚本描述的地址空间布局，把编译好的各个程序片段填充到内核程序文件中

```
OUTPUT_FORMAT("elf64-x86-64","elf64-x86-64","elf64-x86-64")
OUTPUT_ARCH(i386:x86-64)
ENTRY(_start)
SECTIONS
{

	. = 0xffff800000000000 + 0x100000;
	.text :
	{
		_text = .;
		*(.text)

		_etext = .;
	}
	. = ALIGN(8);
	.data :
	{
		_data = .;
		*(.data)
		
		_edata = .;
	}
	.bss :
	{
		_bss = .;
		*(.bss)
		_ebss = .;
	}

	_end = .;
}
```

目前先不讲，只需记住内核层的起始线性地址0xffff800000000000对应着物理地址0处，内核程序的起始线性地址位于0xffff800000000000 + 0x100000处即可

内核执行头程序的位置图：

![内核执行头](https://raw.githubusercontent.com/Enid1107/TyporaImgBed/main/Img/202309041959833.png)

### 写一个内核执行头程序

#### 描述符表和段结构定义

伪指令**.globl**来修饰标识符GDT_Table、IDT_Table ,TSS64_Table，以使这三个标识符可以被外部程序引用或访问。

##### 全局描述符表

```assembly
.section .data

.globl GDT_Table

GDT_Table:
	.quad	0x0000000000000000			
	.quad	0x0020980000000000			
	.quad	0x0000920000000000			
	.quad	0x0020f80000000000			
	.quad	0x0000f20000000000			
	.quad	0x00cf9a000000ffff			
	.quad	0x00cf92000000ffff		
	.fill	10,8,0					
GDT_END:

GDT_POINTER:
GDT_LIMIT:	.word	GDT_END - GDT_Table - 1
GDT_BASE:	.quad	GDT_Table
```

GDT_Table后面都是用于初始化GDT

.quad  用于定义64位宽的描述符

**.quad	0x0000000000000000** 这是NULL描述符，用于初始化GDT的第一个位置

**.quad	0x0020980000000000** 内核代码段的64位描述符。0x20 : 描述DPL（Descriptor Privilege Level）和其他的标志。DPL是0，表示这是内核级代码。0x98 : 标明这是一个代码段，可读，非一致性（参考之前GDT中的段描述符解释）

**.quad	0x0000920000000000** 内核数据段的64位描述符。0x00 : 描述DPL和其他标志，DPL为0。0x92 : 标明这是一个数据段，可写，向上扩展

**.quad	0x0020f80000000000** 用户模式的代码段描述符。0x20 : DPL设置为3，这是用户级代码。0xF8 : 也标明这是一个代码段，可读

**.quad	0x0000f20000000000** 用户模式的数据段描述符。0x00 : DPL设置为3。0xF2 : 标明这是一个数据段，可写

**.quad	0x00cf9a000000ffff** 32位模式下的内核代码段描述符。`0xCF`: 包括一些标志和限制。0x9A : 标明这是一个代码段，可读。0xFFFF : 段限制，表示段的大小。

**.quad	0x00cf92000000ffff** 32位模式下的内核数据段描述符

**.fill	10,8,0** 创建了10个用零填充的64位描述符，可能用于任务状态段（TSS）

**GDT_LIMIT:	.word	GDT_END - GDT_Table - 1** 存储了GDT的大小（实际大小减去1）

**GDT_BASE:	.quad	GDT_Table** 存储了GDT的基础地址

##### 中断描述符表

```assembly
.globl IDT_Table

IDT_Table:
	.fill  512,8,0
IDT_END:

IDT_POINTER:
IDT_LIMIT:	.word	IDT_END - IDT_Table - 1
IDT_BASE:	.quad	IDT_Table
```

**.fill  512,8,0** 在IDT表中填充512个8字节大小的0。在x86-64架构下，一个IDT入口通常是8字节

##### 任务状态段

```assembly
.globl	TSS64_Table

TSS64_Table:
	.fill  13,8,0
TSS64_END:

TSS64_POINTER:
TSS64_LIMIT:	.word	TSS64_END - TSS64_Table - 1
TSS64_BASE:	.quad	TSS64_Table
```

**.fill  512,8,0** TSS表中填充13个8字节大小的0。在x86-64架构下，TSS的大小是可变的，但通常至少为104字节（在这里为104字节）

**TSS64_LIMIT:	.word	TSS64_END - TSS64_Table - 1** 这是计算TSS表的大小并将其存储为一个字（16位）。这里减1是因为计数是从0开始的

**TSS64_BASE:	.quad	TSS64_Table** 存储了TSS表的基础地址

**什么是TSS？**

TSS (Task State Segment) 是x86架构中的一个数据结构，用于存储与特定任务相关的状态信息。在早期的x86 CPU和操作模式（如实模式和保护模式的早期版本）中，TSS用于硬件任务切换，但由于其低效，现代操作系统通常使用软件进行任务切换，并不依赖TSS。

作用：

-   特权级变换：当从一个特权级切换到另一个特权级（例如，从用户模式切换到内核模式）时，TSS中的信息决定了新的栈在哪里以及如何设置。这对于中断、异常和系统调用特别重要。
-   硬件任务切换：虽然现代操作系统很少使用硬件任务切换，但x86架构仍支持这一功能。在这种情况下，TSS保存和恢复与任务相关的所有CPU状态，从而允许任务之间的快速切换。
-   I/O权限位图：在保护模式下，TSS可以包含一个I/O权限位图，该位图定义了任务对各个I/O端口的访问权限。

#### 初始化页表及页表项

```assembly
.align 8

.org	0x1000

__PML4E:

	.quad	0x102007
	.fill	255,8,0
	.quad	0x102007
	.fill	255,8,0

.org	0x2000

__PDPTE:
	
	.quad	0x103003
	.fill	511,8,0

.org	0x3000

__PDE:

	.quad	0x000083	
	.quad	0x200083
	.quad	0x400083
	.quad	0x600083
	.quad	0x800083
	.quad	0xe0000083		
	.quad	0xe0200083
	.quad	0xe0400083
	.quad	0xe0600083		
	.quad	0xe0800083
	.quad	0xe0a00083
	.quad	0xe0c00083
	.quad	0xe0e00083
	.fill	499,8,0
```

在64位的IA-32e模式下，页表最高可分为4个等级（PML4、PDPT、PDE、PTE），每个页表项由原来的4B扩展至8B，而且分页机制除了提供4KB大小的物理页外，还提供2MB和1 GB大小的物理页。

**.align 8** 确保数据在8字节边界上对齐

初始化内容参考之前GDT中的段描述符解释

使用代码.org 0x1000定位页目录后，此页表便位于内核执行头程序起始地址0x1000偏移处，然后链接器再根据链接脚本的描述，将内核执行头程序的起始线性地址设置在0xffff800000000000 + 0x100000地址处，因此推算出页目录的起始线性地址位于0xffff 800000100000+ 0x1000 = 0xffff800000101000处。此页表将线性地址0和0xffff800000000000映射为同一物理页以方便页表切换，即程序在配置页表前运行于线性地址0x100000附近，经过跳转后运行于线性地址0xffff800000000000附近。

一页为4KB，8bit。因此推算出页目录的起始线性地址位于0xffff 800000100000+0x1000 = 0xffff800000101000处

**__PML4E** 这是一个标签，表示下面的数据是PML4（Page Map Level 4）条目

**.quad	0x102007** 定义一个64位的数值，这是PML4的第一个条目，指向下一级的页目录指针表。

**.fill	255,8,0** 填充了255个8字节的0。这是为了填充PML4的其余部分，因为PML4总共有512个条目

**__PDPTE** 这是一个标签，表示下面的数据是页目录指针表条目

**.quad 0x103003** 定义一个64位的数值，这是页目录指针表的第一个条目，指向下一级的页目录

**__PDE** 这是一个标签，表示下面的数据是页目录条目

**.quad	0x000083**   **.quad	0x200083**   **.quad	0x400083**  ……每个条目指向一个2MB的物理页面，将前10MB物理内存分别映射到线性地址o处和Oxffff800000000000处

**.quad	0xe0000083**	 **.quad	0xe0200083**	 **.quad	0xe0400083** ……把物理地址0xe0000000开始的16MB内存映射到线性地址0xa00000处和0xffff800000a00000处

**为什么要确保数据在8字节边界上对齐？**

-   性能优化：对齐到CPU缓存行或内存页边界可以提高内存访问速度。不对齐的数据可能需要额外的内存访问周期
-   硬件要求：某些硬件平台要求数据在特定边界上对齐以正确工作
-   易用性和可移植性：对齐数据可以使得硬件更容易处理，也能提高代码在不同平台间的可移植性
-   避免“未对齐访问”异常：在某些架构（如SPARC、Itanium）上，访问未对齐的数据会导致硬件异常

**什么是PML4条目？**

**为什么.quad	0x102007 .fill	255,8,0要进行两次？** 

#### 再次IA-32e模式的初始化

多次使用lretq代码来进行段间切换，却未曾使用代码ljmp或lcall，这是因为GAS编译器暂不支持直接远跳转JMP/调用cAL指令。一些指令在64位环境下是不可用的，典型的指令有PUSH CS/DS /ES/ss指令和POP DS/ES/Ss指令，多加注意。

借助汇编代码lretq跳转到模块entry64的起始地址处，从而完成了从线性地址0x100000向地址0xffff800000100000切换的工作。

```assembly
.section .text

.globl _start

_start:

	mov	$0x10,	%ax
	mov	%ax,	%ds
	mov	%ax,	%es
	mov	%ax,	%fs
	mov	%ax,	%ss
	mov	$0x7E00,	%esp

//=======	load GDTR

	lgdt	GDT_POINTER(%rip)

//=======	load	IDTR

	lidt	IDT_POINTER(%rip)

	mov	$0x10,	%ax
	mov	%ax,	%ds
	mov	%ax,	%es
	mov	%ax,	%fs
	mov	%ax,	%gs
	mov	%ax,	%ss

	movq	$0x7E00,	%rsp

//=======	load	cr3

	movq	$0x101000,	%rax
	movq	%rax,		%cr3
	movq	switch_seg(%rip),	%rax
	pushq	$0x08
	pushq	%rax
	lretq

//=======	64-bit mode code

switch_seg:
	.quad	entry64

entry64:
	movq	$0x10,	%rax
	movq	%rax,	%ds
	movq	%rax,	%es
	movq	%rax,	%gs
	movq	%rax,	%ss
	movq	$0xffff800000007E00,	%rsp		

	movq	go_to_kernel(%rip),	%rax		
	pushq	$0x08
	pushq	%rax
	lretq

go_to_kernel:
	.quad	Start_Kernel
```

**mov	$0x10,	%ax**  0x10是用于指定一个具体的GDT条目，通常是内核数据段

**movq	$0x101000,	%rax** 0x101000 是页目录表的物理地址

**.quad	entry64** 64位代码的入口点

**movq	$0xffff800000007E00,	%rsp** 0xffff800000007E00是内核空间

汇编代码lgdt GDr_POINTER(%rip)采用的是RIP-Relative寻址模式这是为IA-32e模式新引入的寻址方法。

RIP-Relative寻址格式表：

![RIP-Relative寻址格式表](https://raw.githubusercontent.com/Enid1107/TyporaImgBed/main/Img/202309051230718.png)

#### 编译head.s文件

```bash
gcc -E head.S > head.s
as --64 -o head.o head.s
```

### 内核主程序

**什么是内核主程序？**

内核主程序，或称内核主函数，相当于应用程序的主函数，它与主函数的不同之处在于，内核主程序在正常情况下是不会返回的。因为内核执行头程序没有给内核主程序提供返回地址，而且关机、重启等功能也并非是在内核主程序返回的过程里实现的，所以没有必要让内核主程序返回。

#### Start_Kernel函数

```c
void Start_Kernel(void)
{
	while(1)
		;
}
```

没有返回地址，一旦进入将保持死循环状态

#### 编译main.c文件生成内核程序

```bash
gcc -mcmodel=large -fno-builtin -m64 -c main.c
```

#### 编译成可执行程序

```bash
ld -b elf64-x86-64 -o system head.o main.o -T kernel.lds
```

#### 将system文件中的二进制程序提取出来

```bash
objcopy -I elf64-x86-64 -S -R ".eh_frame" -R ".comment" -O binary system kernel.bin
```

剔除system程序里多余的段信息，并提取出二进制程序段数据（包括text段、data段以及bss段等）

#### kernel.bin复制到boot.img

使用**复制命令**把生成的内核程序kernel.bin复制到boot.img虚拟软盘镜像文件内，便可启动Bochs虚拟机观看运行效果。

即重新挂载复制

```bash
sudo mount -o loop ./bochs-2.6.8/boot.img /media/img
sudo cp kernel.bin  /media/img
sudo sync
sudo umount /media/img
```

#### 反汇编

使用objdump命令反汇编可执行程序system.

```bash
objdump -D system
```

![反汇编](https://raw.githubusercontent.com/Enid1107/TyporaImgBed/main/Img/202309301642651.png)

向终端命令行输人r命令查看通用寄存器内的数据



![反汇编终端](https://raw.githubusercontent.com/Enid1107/TyporaImgBed/main/Img/202309301645461.png)

rip的值和反汇编描述的值相同，说明在这个地方有死循环。代码正确。

# 屏幕显示

为了在屏幕上显示颜色，则必须通过帧缓冲存储器来完成

**什么是帧缓冲存储器？**

帧缓冲存储器（Frame Buffer )，简称帧缓存或帧存，它是屏幕显示画面的一个内存映象，帧缓存的每个存储单元对应屏幕上的一个像素，整个帧缓存对应一幅帧图像。帧缓存的特点是可对每个像素点进行操作，不仅可以借助它在屏幕上画出色彩，还可以在屏幕上用像素点描绘文字及图片。

**帧缓存的格式**

一个像素点能够显示的颜色值位宽。Loader引导加载程序设置的显示模式可支持32位颜色深度的像素点，其中0~7位代表蓝颜色，8~15位代表绿颜色，16~23位代表红颜色，24~31位是保留位。这32 bit位值可以组成16M种不同的颜色，可以表现出真实的色彩。

**怎样设置屏幕上某个像素点的颜色？**

必须知道这个点在屏幕上的位置，并计算出该点距屏幕原点的偏移值，随后才可在偏移处设置此像素点的颜色值。

本系统的原点位于左上方

![屏幕坐标示意图](../../MicroHex64/%E6%9C%AA%E7%BB%84%E7%BB%87%E7%85%A7%E7%89%87/%E5%B1%8F%E5%B9%95%E5%9D%90%E6%A0%87%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

## 屏幕显示色带

```c
void Start_Kernel(void)
{
	int *addr = (int *)0xffff800000a00000;
	int i;


	for(i = 0 ;i<1440*20;i++)
	{
		*((char *)addr+0)=(char)0x00;
		*((char *)addr+1)=(char)0x00;
		*((char *)addr+2)=(char)0xff;
		*((char *)addr+3)=(char)0x00;	
		addr +=1;	
	}
	for(i = 0 ;i<1440*20;i++)
	{
		*((char *)addr+0)=(char)0x00;
		*((char *)addr+1)=(char)0xff;
		*((char *)addr+2)=(char)0x00;
		*((char *)addr+3)=(char)0x00;	
		addr +=1;	
	}
	for(i = 0 ;i<1440*20;i++)
	{
		*((char *)addr+0)=(char)0xff;
		*((char *)addr+1)=(char)0x00;
		*((char *)addr+2)=(char)0x00;
		*((char *)addr+3)=(char)0x00;	
		addr +=1;	
	}
	for(i = 0 ;i<1440*20;i++)
	{
		*((char *)addr+0)=(char)0xff;
		*((char *)addr+1)=(char)0xff;
		*((char *)addr+2)=(char)0xff;
		*((char *)addr+3)=(char)0x00;	
		addr +=1;	
	}

	while(1)
		;
}
```

这段代码通过几组循环语句向每1440*20个像素点依次写入红色值（0x00ff0000)、绿色值（ 0x0000ff00)、蓝色值（0x000000ff)、白色值（ 0x00ffffff )

在head.S中物理地址0xe0000000开始的16MB内存映射到线性地址0xa00000处和0xffff800000a00000处，也就是帧缓存的物理基地址（0xe0000000 )映射到线性地址0xffff8000o0a0o000和0xa00000处

**int *addr = (int *)0xffff800000a00000**  初始化一个整数指针addr ，并将其指向内存地址 0xffff800000a00000 ，也就是帧缓存的物理基地址

**addr +=1**  指针都会增加1，这意味着它会移动到下一个整数位置，即下一个像素

图像显示如下

![四色图](../../MicroHex64/%E6%9C%AA%E7%BB%84%E7%BB%87%E7%85%A7%E7%89%87/%E5%9B%9B%E8%89%B2%E5%9B%BE.png)

特殊说明在设置显示模式的过程中，有个寄存器位可以在设置显示模式后清除屏幕上的数据。Loader引导加载程序已将该寄存器位置位，所以早前在屏幕上显示的信息皆已被清除。

## 屏幕上显示logo

基于ASCII字符集制作出一个ASCII字符的子集，其中包含大小写字母、数字以及一些常用符号，并实现一个简单的格式输出函数color_printk，通过此函数可在屏幕上打印出格式化的彩色字符串

只要根据像素点矩阵的映射原理，计算出每行的十六进制数值，再将这16行数值组合起来就构成了字符像素位图。

### ASCII字符像素位图

```c
#ifndef __FONT_H__
#define __FONT_H__

unsigned char font_ascii[256][16]=
{
	/*	0000	*/
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},

	/*	0010	*/
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},

	/*	0020	*/
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},

	/*	0030	*/
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x00,0x00,0x10,0x10,0x00,0x00},	//33	'!'
	{0x28,0x28,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},	//	'"'
	{0x00,0x44,0x44,0x44,0xfe,0x44,0x44,0x44,0x44,0x44,0xfe,0x44,0x44,0x44,0x00,0x00},	//	'#'
	{0x10,0x3a,0x56,0x92,0x92,0x90,0x50,0x38,0x14,0x12,0x92,0x92,0xd4,0xb8,0x10,0x10},	//	'$'
	{0x62,0x92,0x94,0x94,0x68,0x08,0x10,0x10,0x20,0x2c,0x52,0x52,0x92,0x8c,0x00,0x00},	//	'%'
	{0x00,0x70,0x88,0x88,0x88,0x90,0x60,0x47,0xa2,0x92,0x8a,0x84,0x46,0x39,0x00,0x00},	//	'&'
	{0x04,0x08,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},	//	'''

	/*	0040	*/
	{0x02,0x04,0x08,0x08,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x08,0x08,0x04,0x02,0x00},	//	'('
	{0x80,0x40,0x20,0x20,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x20,0x20,0x40,0x80,0x00},	//	')'
	{0x00,0x00,0x00,0x00,0x00,0x10,0x92,0x54,0x38,0x54,0x92,0x10,0x00,0x00,0x00,0x00},	//	'*'
	{0x00,0x00,0x00,0x00,0x00,0x10,0x10,0x10,0xfe,0x10,0x10,0x10,0x00,0x00,0x00,0x00},	//	'+'
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x08,0x08,0x10},	//	','
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00},	//	'-'
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00},	//	'.'
	{0x02,0x02,0x04,0x04,0x08,0x08,0x08,0x10,0x10,0x20,0x20,0x40,0x40,0x40,0x80,0x80},	//	'/'
	{0x00,0x18,0x24,0x24,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x24,0x24,0x18,0x00,0x00},	//48	'0'
	{0x00,0x08,0x18,0x28,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x3e,0x00,0x00},	//	'1'

	/*	0050	*/
	{0x00,0x18,0x24,0x42,0x42,0x02,0x04,0x08,0x10,0x20,0x20,0x40,0x40,0x7e,0x00,0x00},	//	'2'
	{0x00,0x18,0x24,0x42,0x02,0x02,0x04,0x18,0x04,0x02,0x02,0x42,0x24,0x18,0x00,0x00},	//	'3'
	{0x00,0x0c,0x0c,0x0c,0x14,0x14,0x14,0x24,0x24,0x44,0x7e,0x04,0x04,0x1e,0x00,0x00},	//	'4'
	{0x00,0x7c,0x40,0x40,0x40,0x58,0x64,0x02,0x02,0x02,0x02,0x42,0x24,0x18,0x00,0x00},	//	'5'
	{0x00,0x18,0x24,0x42,0x40,0x58,0x64,0x42,0x42,0x42,0x42,0x42,0x24,0x18,0x00,0x00},	//	'6'
	{0x00,0x7e,0x42,0x42,0x04,0x04,0x08,0x08,0x08,0x10,0x10,0x10,0x10,0x38,0x00,0x00},	//	'7'
	{0x00,0x18,0x24,0x42,0x42,0x42,0x24,0x18,0x24,0x42,0x42,0x42,0x24,0x18,0x00,0x00},	//	'8'
	{0x00,0x18,0x24,0x42,0x42,0x42,0x42,0x42,0x26,0x1a,0x02,0x42,0x24,0x18,0x00,0x00},	//	'9'
	{0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00},	//58	':'
	{0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x18,0x18,0x08,0x08,0x10},	//	';'

	/*	0060	*/
	{0x00,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x00},	//	'<'
	{0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0x00,0x00,0xfe,0x00,0x00,0x00,0x00,0x00,0x00},	//	'='
	{0x00,0x80,0x40,0x20,0x10,0x08,0x04,0x02,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x00},	//	'>'
	{0x00,0x38,0x44,0x82,0x82,0x82,0x04,0x08,0x10,0x10,0x00,0x00,0x18,0x18,0x00,0x00},	//	'?'
	{0x00,0x38,0x44,0x82,0x9a,0xaa,0xaa,0xaa,0xaa,0xaa,0x9c,0x80,0x46,0x38,0x00,0x00},	//	'@'
	{0x00,0x18,0x18,0x18,0x18,0x24,0x24,0x24,0x24,0x7e,0x42,0x42,0x42,0xe7,0x00,0x00},	//65	'A'
	{0x00,0xf0,0x48,0x44,0x44,0x44,0x48,0x78,0x44,0x42,0x42,0x42,0x44,0xf8,0x00,0x00},	//	'B'
	{0x00,0x3a,0x46,0x42,0x82,0x80,0x80,0x80,0x80,0x80,0x82,0x42,0x44,0x38,0x00,0x00},	//	'C'
	{0x00,0xf8,0x44,0x44,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x44,0x44,0xf8,0x00,0x00},	//	'D'
	{0x00,0xfe,0x42,0x42,0x40,0x40,0x44,0x7c,0x44,0x40,0x40,0x42,0x42,0xfe,0x00,0x00},	//	'E'

	/*	0070	*/
	{0x00,0xfe,0x42,0x42,0x40,0x40,0x44,0x7c,0x44,0x44,0x40,0x40,0x40,0xf0,0x00,0x00},	//	'F'
	{0x00,0x3a,0x46,0x42,0x82,0x80,0x80,0x9e,0x82,0x82,0x82,0x42,0x46,0x38,0x00,0x00},	//	'G'
	{0x00,0xe7,0x42,0x42,0x42,0x42,0x42,0x7e,0x42,0x42,0x42,0x42,0x42,0xe7,0x00,0x00},	//	'H'
	{0x00,0x7c,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x7c,0x00,0x00},	//	'I'
	{0x00,0x1f,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x84,0x48,0x30,0x00},	//	'J'
	{0x00,0xe7,0x42,0x44,0x48,0x50,0x50,0x60,0x50,0x50,0x48,0x44,0x42,0xe7,0x00,0x00},	//	'K'
	{0x00,0xf0,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x42,0x42,0xfe,0x00,0x00},	//	'L'
	{0x00,0xc3,0x42,0x66,0x66,0x66,0x5a,0x5a,0x5a,0x42,0x42,0x42,0x42,0xe7,0x00,0x00},	//	'M'
	{0x00,0xc7,0x42,0x62,0x62,0x52,0x52,0x52,0x4a,0x4a,0x4a,0x46,0x46,0xe2,0x00,0x00},	//	'N'
	{0x00,0x38,0x44,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x44,0x38,0x00,0x00},	//	'O'

	/*	0080	*/
	{0x00,0xf8,0x44,0x42,0x42,0x42,0x44,0x78,0x40,0x40,0x40,0x40,0x40,0xf0,0x00,0x00},	//	'P'
	{0x00,0x38,0x44,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x92,0x8a,0x44,0x3a,0x00,0x00},	//	'Q'
	{0x00,0xfc,0x42,0x42,0x42,0x42,0x7c,0x44,0x42,0x42,0x42,0x42,0x42,0xe7,0x00,0x00},	//	'R'
	{0x00,0x3a,0x46,0x82,0x82,0x80,0x40,0x38,0x04,0x02,0x82,0x82,0xc4,0xb8,0x00,0x00},	//	'S'
	{0x00,0xfe,0x92,0x92,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x7c,0x00,0x00},	//	'T'
	{0x00,0xe7,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x24,0x3c,0x00,0x00},	//	'U'
	{0x00,0xe7,0x42,0x42,0x42,0x42,0x24,0x24,0x24,0x24,0x18,0x18,0x18,0x18,0x00,0x00},	//	'V'
	{0x00,0xe7,0x42,0x42,0x42,0x5a,0x5a,0x5a,0x5a,0x24,0x24,0x24,0x24,0x24,0x00,0x00},	//	'W'
	{0x00,0xe7,0x42,0x42,0x24,0x24,0x24,0x18,0x24,0x24,0x24,0x42,0x42,0xe7,0x00,0x00},	//	'X'
	{0x00,0xee,0x44,0x44,0x44,0x28,0x28,0x28,0x10,0x10,0x10,0x10,0x10,0x7c,0x00,0x00},	//	'Y'

	/*	0090	*/
	{0x00,0xfe,0x84,0x84,0x08,0x08,0x10,0x10,0x20,0x20,0x40,0x42,0x82,0xfe,0x00,0x00},	//	'Z'
	{0x00,0x3e,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x3e,0x00},	//91	'['
	{0x80,0x80,0x40,0x40,0x20,0x20,0x20,0x10,0x10,0x08,0x08,0x04,0x04,0x04,0x02,0x02},	//	'\'
	{0x00,0x7c,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x7c,0x00},	//	']'
	{0x00,0x10,0x28,0x44,0x82,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},	//	'^'
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0x00},	//	'_'
	{0x10,0x08,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},	//	'`'
	{0x00,0x00,0x00,0x00,0x00,0x70,0x08,0x04,0x3c,0x44,0x84,0x84,0x8c,0x76,0x00,0x00},	//97	'a'
	{0xc0,0x40,0x40,0x40,0x40,0x58,0x64,0x42,0x42,0x42,0x42,0x42,0x64,0x58,0x00,0x00},	//	'b'
	{0x00,0x00,0x00,0x00,0x00,0x30,0x4c,0x84,0x84,0x80,0x80,0x82,0x44,0x38,0x00,0x00},	//	'c'

	/*	0100	*/
	{0x0c,0x04,0x04,0x04,0x04,0x34,0x4c,0x84,0x84,0x84,0x84,0x84,0x4c,0x36,0x00,0x00},	//	'd'
	{0x00,0x00,0x00,0x00,0x00,0x38,0x44,0x82,0x82,0xfc,0x80,0x82,0x42,0x3c,0x00,0x00},	//	'e'
	{0x0e,0x10,0x10,0x10,0x10,0x7c,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x7c,0x00,0x00},	//	'f'
	{0x00,0x00,0x00,0x00,0x00,0x36,0x4c,0x84,0x84,0x84,0x84,0x4c,0x34,0x04,0x04,0x38},	//	'g'
	{0xc0,0x40,0x40,0x40,0x40,0x58,0x64,0x42,0x42,0x42,0x42,0x42,0x42,0xe3,0x00,0x00},	//	'h'
	{0x00,0x10,0x10,0x00,0x00,0x30,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x38,0x00,0x00},	//	'i'
	{0x00,0x04,0x04,0x00,0x00,0x0c,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x08,0x08,0x30},	//	'j'
	{0xc0,0x40,0x40,0x40,0x40,0x4e,0x44,0x48,0x50,0x60,0x50,0x48,0x44,0xe6,0x00,0x00},	//	'k'
	{0x30,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x38,0x00,0x00},	//	'l'
	{0x00,0x00,0x00,0x00,0x00,0xf6,0x49,0x49,0x49,0x49,0x49,0x49,0x49,0xdb,0x00,0x00},	//	'm'

	/*	0110	*/
	{0x00,0x00,0x00,0x00,0x00,0xd8,0x64,0x42,0x42,0x42,0x42,0x42,0x42,0xe3,0x00,0x00},	//	'n'
	{0x00,0x00,0x00,0x00,0x00,0x38,0x44,0x82,0x82,0x82,0x82,0x82,0x44,0x38,0x00,0x00},	//	'o'
	{0x00,0x00,0x00,0x00,0xd8,0x64,0x42,0x42,0x42,0x42,0x42,0x64,0x58,0x40,0x40,0xe0},	//	'p'
	{0x00,0x00,0x00,0x00,0x34,0x4c,0x84,0x84,0x84,0x84,0x84,0x4c,0x34,0x04,0x04,0x0e},	//	'q'
	{0x00,0x00,0x00,0x00,0x00,0xdc,0x62,0x42,0x40,0x40,0x40,0x40,0x40,0xe0,0x00,0x00},	//	'r'
	{0x00,0x00,0x00,0x00,0x00,0x7a,0x86,0x82,0xc0,0x38,0x06,0x82,0xc2,0xbc,0x00,0x00},	//	's'
	{0x00,0x00,0x10,0x10,0x10,0x7c,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x0e,0x00,0x00},	//	't'
	{0x00,0x00,0x00,0x00,0x00,0xc6,0x42,0x42,0x42,0x42,0x42,0x42,0x46,0x3b,0x00,0x00},	//	'u'
	{0x00,0x00,0x00,0x00,0x00,0xe7,0x42,0x42,0x42,0x24,0x24,0x24,0x18,0x18,0x00,0x00},	//	'v'
	{0x00,0x00,0x00,0x00,0x00,0xe7,0x42,0x42,0x5a,0x5a,0x5a,0x24,0x24,0x24,0x00,0x00},	//	'w'

	/*	0120	*/
	{0x00,0x00,0x00,0x00,0x00,0xc6,0x44,0x28,0x28,0x10,0x28,0x28,0x44,0xc6,0x00,0x00},	//	'x'
	{0x00,0x00,0x00,0x00,0x00,0xe7,0x42,0x42,0x24,0x24,0x24,0x18,0x18,0x10,0x10,0x60},	//	'y'
	{0x00,0x00,0x00,0x00,0x00,0xfe,0x82,0x84,0x08,0x10,0x20,0x42,0x82,0xfe,0x00,0x00},	//	'z'
	{0x00,0x06,0x08,0x10,0x10,0x10,0x10,0x60,0x10,0x10,0x10,0x10,0x08,0x06,0x00,0x00},	//	'{'
	{0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10},	//	'|'
	{0x00,0x60,0x10,0x08,0x08,0x08,0x08,0x06,0x08,0x08,0x08,0x08,0x10,0x60,0x00,0x00},	//	'}'
	{0x00,0x72,0x8c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},	//	'~'
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},

	/*	0130	*/
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},


	/*	0140	*/
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},

	/*	0150	*/
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},

	/*	0160	*/
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},

	/*	0170	*/
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},

	/*	0180	*/
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},

	/*	0190	*/
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},

	/*	0200	*/
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},

	/*	0210	*/
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},

	/*	0220	*/
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},

	/*	0230	*/
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},

	/*	0240	*/
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},

	/*	0250~0255	*/
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},


};

#endif

```

这段程序中的每对大括号保存着一个字符的字符像素位图。在字符的显示过程中，只需把位图中为1的位写入字体颜色值，将位图中为0的位写入字体背景颜色值，便可将该字符显示在屏幕上。

### color  printk的实现

#### 屏幕信息结构体

```c
struct position
{
	int XResolution;  
	int YResolution;

	int XPosition;
	int YPosition;

	int XCharSize;
	int YCharSize;

	unsigned int * FB_addr;  //起始位置
	unsigned long FB_length;  //字节数或像素数
}Pos;
```

该结构体记录着当前屏幕分辨率、字符光标所在位置、字符像素矩阵尺寸、帧缓存区起始地址和帧缓存区容量大小

#### 头文件

##### printk.h

```c
#include <stdarg.h>
#include "font.h"
#include "linkage.h"
```

##### printk.c

```c
#include <stdarg.h>
#include "printk.h"
#include "lib.h"
#include "linkage.h"
```

**stdarg.h**，它是GNUC编译环境自带的头文件，只有添加引用这个头文件后,才可使用可变参数的相关功能。

**#include "linkage.h"**   **#include "lib.h"** 本系统编写的内核通用库函数、宏定义以及一些常用的函数修饰符

####  color_printk函数

```c
int color_printk(unsigned int FRcolor,unsigned int BKcolor,const char * fmt,...)
```

##### 参数函数定义

```c
int i = 0;
int count = 0;
int line = 0;
va_list args;
va_start(args, fmt);

i = vsprintf(buf,fmt, args);

va_end(args);
```

**va_list**  这是一个数据类型，用于声明一个变量，该变量将被用作一个参数指针，用于访问函数的可变参数

**va_start**  这是一个宏，用于初始化**va_list**类型的变量。它需要两个参数：第一个是上面提到的**va_list**变量，第二个是可变参数函数的最后一个固定参数。**fmt **就是这个最后的固定参数。

**va_end**  这个宏用于清理。在使用完**va_list** 变量后，你应该调用**va_end**来进行清理

书上说这些为关键字，但是我更倾向于C标准库中定义的宏

**args**  变量，用于访问可变参数

**fmt**  函数的一个固定参数，它通常是一个格式字符串，用于指定后续可变参数的格式。这是类似于 **printf **和 **scanf **函数中使用的格式字符串

**为什么需要这些定义？**

因为C语言没有直接的方式来处理可变数量的参数。通过使用 **va_list **和相关的宏，我们可以在C中实现这种功能。这种机制允许函数接受任意数量的参数，例如**printf **函数就是一个很好的例子

##### 检索格式化字符串

###### \n

```c
if((unsigned char)*(buf + count) == '\n')
{
	Pos.YPosition++;
	Pos.XPosition = 0;
}
```

当前字符为**\n** ，换到下一行

###### \b

\b的含义是，将光标从当前位置向前（左）移动一个字符（遇到\n或\r则停止移动），并从此位置开始输出后面的字符（空字符\0和换行符\n除外）

```c
else if((unsigned char)*(buf + count) == '\b')
{
	Pos.XPosition--;
	if(Pos.XPosition < 0)
	{
		Pos.XPosition = (Pos.XResolution / Pos.XCharSize - 1) * Pos.XCharSize; //当XPosition小于0，换到上一行末尾
		Pos.YPosition--;  //光标上移，YPosition--
		if(Pos.YPosition < 0)  //同样判断YPosition
			Pos.YPosition = (Pos.YResolution / Pos.YCharSize - 1) * Pos.YCharSize;
	}	
	putchar(Pos.FB_addr , Pos.XResolution , Pos.XPosition * Pos.XCharSize , Pos.YPosition * Pos.YCharSize , FRcolor , BKcolor , ' ');	
}
```

###### \t

```c
else if((unsigned char)*(buf + count) == '\t')
{
	line = ((Pos.XPosition + 8) & ~(8 - 1)) - Pos.XPosition;  //计算当前光标距下一个制表位需要填充的空格符数量，一个制表位占用8个显示字符

Label_tab:
	line--;
	putchar(Pos.FB_addr , Pos.XResolution , Pos.XPosition * Pos.XCharSize , Pos.YPosition * Pos.YCharSize , FRcolor , BKcolor , ' ');	
	Pos.XPosition++;
}
```

##### 普通字符打印

```c
else
{
	putchar(Pos.FB_addr , Pos.XResolution , Pos.XPosition * Pos.XCharSize , Pos.YPosition * Pos.YCharSize , FRcolor , BKcolor , (unsigned char)*(buf + count));
	Pos.XPosition++;
}
```

这里需要给putchar函数传递帧缓存线性地址、行分辨率、屏幕列像素点位置、屏幕行像素点位置、字体颜色、字体背景色和字符位图等参数

##### 更新当前字符的显示位置

```c
if(Pos.XPosition >= (Pos.XResolution / Pos.XCharSize))  //超出当前每行像素，移到下一行
{
	Pos.YPosition++;
	Pos.XPosition = 0;
}
if(Pos.YPosition >= (Pos.YResolution / Pos.YCharSize))
{
	Pos.YPosition = 0;
}
```

字符显示结束后，还要为下次字符显示做准备，即更新当前字符的显示位置

#### putchar函数

```c
void putchar(unsigned int * fb,int Xsize,int x,int y,unsigned int FRcolor,unsigned int BKcolor,unsigned char font)
{
	int i = 0,j = 0;
	unsigned int * addr = NULL;
	unsigned char * fontp = NULL;  //指向字符位图的指针
	int testval = 0;  //用于检测字符位图中的每一位
	fontp = font_ascii[font];  //获取字符的位图

	for(i = 0; i< 16;i++)
	{
		addr = fb + Xsize * ( y + i ) + x;  //计算当前行的起始地址
		testval = 0x100;  //testval被用作一个掩码来检查fontp指向的字节中的每一位
		for(j = 0;j < 8;j ++)		
		{
			testval = testval >> 1;
			if(*fontp & testval)  //检查字符位图的当前位是否为1
				*addr = FRcolor;  //如果是，则将当前像素设置为前景色
			else
				*addr = BKcolor;  //否则，将其设置为背景色
			addr++;  //移动到下一个像素
		}
		fontp++;  // 移动到字符位图的下一行		 
	}
}
```

**addr = fb + Xsize * ( y + i ) + x**  从y开始为当前字符的起始y，那么**Xsize * y**  计算了在目标行y之前的所有行中的像素数，再加上当前为该字符的第i行，也就是当前行的起始地址，再加上x的偏移

#### vsprintf函数

##### 判断字符是否可显示

```c
int vsprintf(char * buf,const char *fmt, va_list args)
{
	char * str,*s;
	int flags;  //存储格式标志
	int field_width;  //存储字段宽度
	int precision;  //存储字段精度
	int len,i;

	int qualifier;		/* 'h', 'l', 'L' or 'Z' for integer fields */  //用于存储整数字段的修饰符

	for(str = buf; *fmt; fmt++)
	{

		if(*fmt != '%')  //如果字符不为'%'就认为它是个可显示字符，直接将之存入缓冲区buf中
		{
			*str++ = *fmt; //复制到输出字符串buf
			continue;
		}
		flags = 0;
		repeat:
			fmt++;
			switch(*fmt)
			{
				case '-':flags |= LEFT;	
				goto repeat;  //继续检查下一个字符
				case '+':flags |= PLUS;	
				goto repeat;
				case ' ':flags |= SPACE;	
				goto repeat;
				case '#':flags |= SPECIAL;	
				goto repeat;
				case '0':flags |= ZEROPAD;	
				goto repeat;
			}
    }
}
```

##### 计算出数据区域的宽度

```c
field_width = -1;
if(is_digit(*fmt))  //检查当前的字符是否是数字
	field_width = skip_atoi(&fmt);  //将连续的数字字符转换为整数
else if(*fmt == '*')  //如果当前字符是*，这意味着字段宽度是由参数列表中的下一个参数提供的，例如%*d
{
	fmt++;
	field_width = va_arg(args, int);  //使用va_arg宏从args参数列表中获取下一个参数，该参数应该是一个整数，表示字段宽度
	if(field_width < 0)
	{
		field_width = -field_width;  //将字段宽度转换为正数
		flags |= LEFT;  //输出应该左对齐，而不是默认的右对齐 这是printf系列函数中字段宽度为负数的特殊行为。
	}
}
```

代码中的is_digit是一个宏(#define is_digit (c) ((c)>= '0'&&(c)<= '9' ) )

**关于当前字符是*，字段宽度是由参数列表中的下一个参数提供的解释**

在printf 函数中，我们使用格式字符串来决定如何打印变量。例如，%d 是用来打印整数的。

现在，如果我们想要控制打印的整数的宽度（即，它在屏幕上占据的字符数），我们可以这样做：

```c
printf("%5d", 123);
```

这会打印 123 ，但前面有两个空格，所以总共有5个字符的宽度。

但是，如果我们想要在运行时动态决定这个宽度，我们可以使用`*`代替数字，并传递一个额外的参数给 printf 来指定这个宽度。例如：

```c
cCopy codeint width = 5;
printf("%*d", width, 123);
```

这里的 %*d 告诉 printf ： "我想要打印一个整数，但我会在下一个参数中告诉你它的宽度。" 所以， width 变量的值（在这里是5）告诉 printf 整数应该有5个字符的宽度。

##### 提取出显示数据的精度

```c
precision = -1;
if(*fmt == '.')
{
	fmt++;
	if(is_digit(*fmt))
		precision = skip_atoi(&fmt);
	else if(*fmt == '*')
	{	
		fmt++;
		precision = va_arg(args, int);
	}
	if(precision < 0)
	precision = 0;
}
```

如果数据区域的宽度后面跟有字符·.'，说明其后的数值是显示数据的精度。

##### 获取显示数据的规格

```c
qualifier = -1;
if(*fmt == 'h' || *fmt == 'l' || *fmt == 'L' || *fmt == 'Z')
{	
	qualifier = *fmt;
	fmt++;
}
```

用于检测显示数据的规格，比如%ld格式化字符串中的字母'1'，就表示显示数据的规格是长整型数( long型)。

```c
switch(*fmt)
{
	case 'c':  //字符

		if(!(flags & LEFT))  //没有指定左对齐
			while(--field_width > 0)
				*str++ = ' ';  //则在字符前面添加空格，直到达到指定的field_width
		*str++ = (unsigned char)va_arg(args, int);
		while(--field_width > 0)
			*str++ = ' ';
		break;

	case 's':
				
		s = va_arg(args,char *);  //参数列表中获取字符串
		if(!s)
			s = '\0';
		len = strlen(s);
		if(precision < 0)  
			precision = len;  //（精度）为负，则将其设置为字符串的长度。这意味着没有指定精度限制
		else if(len > precision)  
			len = precision;  //如果指定了精度，并且字符串的长度大于这个精度，则将字符串的长度设置为这个精度。这意味着只会输出字符串的前 precision 个字符
					
		if(!(flags & LEFT))
			while(len < field_width--)
				*str++ = ' ';
		for(i = 0;i < len ;i++)
			*str++ = *s++;
		while(len < field_width--)
			*str++ = ' ';
		break;

	case 'o':  // 八进制数
					
		if(qualifier == 'l')  //根据qualifier来决定是处理long还是int
			str = number(str,va_arg(args,unsigned long),8,field_width,precision,flags);
		else
			str = number(str,va_arg(args,unsigned int),8,field_width,precision,flags);
		break;

	case 'p':  //指针

		if(field_width == -1)
		{
			field_width = 2 * sizeof(void *);  //设置字段宽度为指针大小的两倍。这是因为在十六进制表示中，每个字节需要两个字符来表示
			flags |= ZEROPAD;  //在必要时，指针的十六进制表示前面将填充零，而不是默认的空格
		}

		str = number(str,(unsigned long)va_arg(args,void *),16,field_width,precision,flags);  //将指针地址转换为十六进制字符串
		break;

	case 'x':  //十六进制数

		flags |= SMALL;

	case 'X':  //十六进制数

		if(qualifier == 'l')
			str = number(str,va_arg(args,unsigned long),16,field_width,precision,flags);
		else
			str = number(str,va_arg(args,unsigned int),16,field_width,precision,flags);
		break;
 
	case 'd':  //十进制数
	case 'i':  //十进制数

		flags |= SIGN;
	case 'u':  //十进制数

		if(qualifier == 'l')
			str = number(str,va_arg(args,unsigned long),10,field_width,precision,flags);
		else
			str = number(str,va_arg(args,unsigned int),10,field_width,precision,flags);
		break;

	case 'n':  // 格式符%n的功能是，把目前已格式化的字符串长度返回给函数的调用者
					
		if(qualifier == 'l')
		{
			long *ip = va_arg(args,long *);
			*ip = (str - buf);  //计算到目前为止已经输出的字符数
		}
		else
		{
			int *ip = va_arg(args,int *);
			*ip = (str - buf);
		}
		break;

	case '%':  //输出一个%字符
					
		*str++ = '%';
		break;

	default: //如果遇到未知的格式字符，输出%和该字符

		*str++ = '%';	
		if(*fmt)
			*str++ = *fmt;
		else
			fmt--;
		break;
}
```

#### skip_atoi函数

将数值字母转换成整数值

```c
int skip_atoi(const char **s)
{
	int i=0;

	while (is_digit(**s))
		i = i*10 + *((*s)++) - '0';  //转化为十进制数
	return i;
}
```

#### number函数

可将整数值按照指定进制规格转换成字符串

最高支持36进制的数值转换

```c
static char * number(char * str, long num, int base, int size, int precision,	int type)
{
	char c,sign,tmp[50];
	const char *digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";  //用于转换的字符集
	int i;

	if (type&SMALL) digits = "0123456789abcdefghijklmnopqrstuvwxyz";  //如果type包含SMALL标志，则使用小写字母的字符集
	if (type&LEFT) type &= ~ZEROPAD;  //如果LEFT标志被设置，这行代码会清除type中的ZEROPAD标志。这是因为左对齐和零填充是互斥的：你不能同时有左对齐的输出和零填充
	if (base < 2 || base > 36)  
		return 0;  //base不在2到36之间，函数返回0
	c = (type & ZEROPAD) ? '0' : ' ' ;
	sign = 0;
	if (type&SIGN && num < 0) {  //数字是负数
		sign='-';
		num = -num;
	} else
		sign=(type & PLUS) ? '+' : ((type & SPACE) ? ' ' : 0);
	if (sign) size--;  //如果有符号（即sign不为0），则size（预期的输出大小）减1，以考虑到符号字符
	if (type & SPECIAL)
		if (base == 16) size -= 2;  //如果数字是十六进制，并且SPECIAL标志被设置，那么size减2（考虑到0x前缀）
		else if (base == 8) size--;  //如果数字是八进制，size减1（考虑到0前缀）
	i = 0;
	if (num == 0)
		tmp[i++]='0';  //如果数字是0，直接在tmp数组中存储字符'0'
	else while (num!=0)
		tmp[i++]=digits[do_div(num,base)];  //do_div(num, base)函数返回num除以base的余数，并更新num为商
	if (i > precision) precision=i;  //如果数字的实际长度i大于指定的精度precision，则更新精度为i
	size -= precision;  //从字段宽度size中减去精度，得到需要填充的空格或零的数量
	if (!(type & (ZEROPAD + LEFT)))  //如果没有设置ZEROPAD和LEFT标志
		while(size-- > 0)
			*str++ = ' ';
	if (sign)  //如果存在符号（正号、负号或空格）
		*str++ = sign;
	if (type & SPECIAL)
		if (base == 8)  //对于八进制，添加前缀0
			*str++ = '0';
		else if (base==16)   //对于十六进制，添加前缀0x或0X
		{
			*str++ = '0';
			*str++ = digits[33];
		}
	if (!(type & LEFT))  //如果没有设置LEFT标志，则在数字前填充字符（空格或零）
		while(size-- > 0)
			*str++ = c;

	while(i < precision--)
		*str++ = '0';  //如果数字的实际长度小于指定的精度，填充前导零
	while(i-- > 0)
		*str++ = tmp[i]; //数字是反向存储的，所以从最后一个字符开始复制
	while(size-- > 0)
		*str++ = ' ';  //如果还有剩余的字段宽度，用空格填充
	return str;
}
```

do_div宏的代码实现:

```
#define do_div(n,base)({ \
int __res;\
__asm__("divq %%rcx":"=a" (n),"=d" (__res):"0" (n),"1" (0),"c" (base));\
__res;})
```

do_div宏是一条内嵌汇编语句，它借助DIV汇编指令将整数值num除以进制规格base(在DIV汇编指令中，被除数由RDX:RAX寄存器组成，由于num变量是个8 B的长整型变量，因此RDX寄存器被赋值为0)，计算结果的余数部分即是digits数组的下标索引值。

#### 通用库函数strlen(lib.h)

```
inline int strlen(char * String)
{
	register int __res;
	__asm__	__volatile__	(	"cld	\n\t"
					"repne	\n\t"
					"scasb	\n\t"
					"notl	%0	\n\t"
					"decl	%0	\n\t"
					:"=c"(__res)
					:"D"(String),"a"(0),"0"(0xffffffff)
					:
				);
	return __res;
}
```

这是一个内联函数，意味着每次调用这个函数时，编译器可能会直接插入函数的代码，而不是生成函数调用。这可以提高性能，但可能会增加生成的代码的大小。

`__asm__	__volatile__ ` 这是GNU C的内联汇编语法的开始。`__volatile__`告诉编译器不要优化这段汇编代码

在这段内联汇编代码中，`\n` 和 `\t` 被用作汇编指令的分隔符。这是为了使汇编代码更具可读性，并确保每条指令都从新行开始

`cld`是一个汇编指令，它清除方向标志（DF）。这确保`repne`和`scasb`指令从低地址向高地址搜索

`repne`是一个前缀，它告诉CPU重复下一个指令，直到ECX寄存器为零或ZF（零标志）为1

`scasb`指令比较AL寄存器的内容和ES:DI指向的内存字节，并递增或递减DI寄存器（取决于DF标志）。在这里，它用于搜索字符串的结束字符`\0`

`notl`指令对操作数执行逻辑非操作。这里，它对`__res`（即ECX寄存器）执行逻辑非操作

`decl`指令递减操作数的值。这里，它递减`__res`的值

``:"=c"(__res)``这是输出操作数列表。它告诉编译器`__res`变量将包含ECX寄存器的内容

`:"D"(String),"a"(0),"0"(0xffffffff)`  这是输入操作数列表。它设置DI寄存器为`String`的值，AL寄存器为0，并设置ECX寄存器为`0xffffffff`

### 打印字符串Hello world!

```c
#include "lib.h"
#include "printk.h"

void Start_Kernel(void)
{
	int *addr = (int *)0xffff800000a00000;
	int i;

	Pos.XResolution = 1440;
	Pos.YResolution = 900;  //屏幕分辨率

	Pos.XPosition = 0;  //从屏幕的左上角开始
	Pos.YPosition = 0;

	Pos.XCharSize = 8;  //设置字符的大小
	Pos.YCharSize = 16;

	Pos.FB_addr = (int *)0xffff800000a00000;
	Pos.FB_length = (Pos.XResolution * Pos.YResolution * 4);  //设置帧缓冲区的长度 乘以4是因为每个像素通常由4个字节表示

	for(i = 0 ;i<1440*20;i++)  //蓝色条带
	{
		*((char *)addr+0)=(char)0x00;
		*((char *)addr+1)=(char)0x00;
		*((char *)addr+2)=(char)0xff;
		*((char *)addr+3)=(char)0x00;	
		addr +=1;	
	}
	for(i = 0 ;i<1440*20;i++)  //绿色条带
	{
		*((char *)addr+0)=(char)0x00;
		*((char *)addr+1)=(char)0xff;
		*((char *)addr+2)=(char)0x00;
		*((char *)addr+3)=(char)0x00;	
		addr +=1;	
	}
	for(i = 0 ;i<1440*20;i++)  //红色条带
	{
		*((char *)addr+0)=(char)0xff;
		*((char *)addr+1)=(char)0x00;
		*((char *)addr+2)=(char)0x00;
		*((char *)addr+3)=(char)0x00;	
		addr +=1;	
	}
	for(i = 0 ;i<1440*20;i++)  //白色条带
	{ 
		*((char *)addr+0)=(char)0xff;
		*((char *)addr+1)=(char)0xff;
		*((char *)addr+2)=(char)0xff;
		*((char *)addr+3)=(char)0x00;	
		addr +=1;	
	}

	color_printk(YELLOW,BLACK,"Hello\t\t World!\n");

	while(1)
		;
}
```

### 编译printk.c

编译时会出现无法找到内联函数，弄了很久不知道为啥就是找不到。后来看了一些讨论，发现开发这个操作系统的gcc版本太高会出现一些问题，推荐环境为gcc4.8。目前ubuntu自动下载gcc为gcc9，需要降版本。

这次内联函数没问题了，又出现一个问题：链接器(ld)在尝试编译程序时找不到 `__stack_chk_fail` 函数的定义

![image-20231104125209855](https://raw.githubusercontent.com/Enid1107/TyporaImgBed/main/Img/202311041252914.png)

`__stack_chk_fail` 函数是堆栈保护机制的一部分，用于检测缓冲区溢出。

解决方法是需要在这个命令中添加 `-fno-stack-protector` 选项

那么编译printk.c命令就变成了：

```sh
gcc -mcmodel=large -fno-builtin -m64 -fno-stack-protector -c printk.c
```

然后再进行system文件生成

```sh
ld -b elf64-x86-64 -z muldefs -o system head.o main.o printk.o -T kernel.lds 
```

将system文件中的二进制程序提取出来

```bash
objcopy -I elf64-x86-64 -S -R ".eh_frame" -R ".comment" -O binary system kernel.bin
```

 kernel.bin复制到boot.img

```bash
sudo mount -o loop ./bochs-2.6.8/boot.img /media/img
sudo cp kernel.bin  /media/img
sudo sync
sudo umount /media/img
```

运行成功如下

![image-20231104124653274](https://raw.githubusercontent.com/Enid1107/TyporaImgBed/main/Img/202311041247444.png)

# 系统异常

**什么是系统异常？**

在处理器的运行过程中，经常会由于执行某条指令、访问内存空间或越权访问等问题，而导致程序无法继续执行，此时处理器会暂停当前的操作转而执行相应的错误处理，这个错误被称作异常。

异常有的是可恢复的，有的是不可恢复的。

## 异常分类

处理器根据异常的报告方式、任务或程序是否可继续执行(从产生异常的指令开始）等因素，大体上会将异常分为错误、陷阱、终止三类。

-   错误（fault)。错误是一种可被修正的异常。只要错误被修正，处理器可将程序或任务的运行环境还原至异常发生前(已在栈中保存CS和EIP寄存器值)，并重新执行产生异常的指令，也就是说异常的返回地址指向产生错误的指令，而不是其后的位置。
-   陷阱（trap)。陷阱异常同样允许处理器继续执行程序或任务，只不过处理器会跳过产生异常的指令，即陷阱异常的返回地址指向诱发陷阱指令之后的地址。
-   终止(abort)。终止异常用于报告非常严重的错误，它往往无法准确提供产生异常的位置，同时也不允许程序或任务继续执行，典型的终止异常有硬件错误或系统表存在不合逻辑、非法值。

综上所述，当终止异常产生后，程序现场不可恢复，也无法继续执行。当错误异常和陷阱异常产生后，程序现场可以恢复并继续执行，只不过错误异常会重新执行产生异常的指令，而陷阱异常会跳过产生异常的指令。

**异常/中断描述表：**

![image-20231104132257967](https://raw.githubusercontent.com/Enid1107/TyporaImgBed/main/Img/202311041322056.png)

![image-20231104132234916](https://raw.githubusercontent.com/Enid1107/TyporaImgBed/main/Img/202311041322962.png)

## 系统异常处理（一）

处理器采用类似汇编指令CALL的调用方法来执行异常/中断处理程序。当处理器捕获到异常/中断时，便会根据异常/中断向量号( Interrupt Vector )从中断描述符表IDT索引出对应的门描述符，再由门描述符定位到处理程序的位置。如果向量号索引到一个中断门或陷阱门，处理器将会像执行cALL指令访问调用门一般，去执行异常/中断处理程序。如果向量号索引到一个任务门,处理器将发生任务切换，转而执行异常任务或中断任务，这个过程就像执行cALL指令访问调用任务门一样。

**异常/中断的处理步骤**

![image-20231104134320914](https://raw.githubusercontent.com/Enid1107/TyporaImgBed/main/Img/202311041343003.png)

处理器会根据中断/异常向量号从中断描述符表IDT检索出对应的门描述符（中断门或陷阱门，Interrupt or Trap Gate )，并读取门描述符保存的段选择子。随后，从GDT或LDT描述符表中检索出处理程序所在代码段，再根据门描述符记录的段内偏移量，来确定中断/异常处理程序的人口地址。

处理器在执行中断/异常处理程序时，会检测中断/异常处理程序所在代码段的特权级，并与代码段寄存器的特权级进行比较。

-   如果中断/异常处理程序的特权级更高，则会在中断/异常处理程序执行前切换栈空间
-   如果中断/异常处理程序的特权级与代码段寄存器的特权级相等。
    -   处理器将保存被中断程序的EFLAGS、CS和EIP寄存器值到栈中
    -   如果异常会产生错误码，则将其保存在异常栈内，位于EIP寄存器之后。

**栈空间的切换过程**

-   处理器会从任务状态段TSS中取出对应特权级的栈段选择子和栈指针，并将它们作为中断/异常处理程序的栈空间进行切换。在栈空间切换的过程中，处理器将自动把切换前的SS和ESP寄存器值压入中断/异常处理程序栈。
-   在栈空间切换的过程中，处理器还会保存被中断程序的EFLAGS、CS和EIP寄存器值到中断/异常处理程序栈。
-   如果异常会产生错误码，则将其保存在异常栈内，位于EIP寄存器之后。

**执行中断/异常处理程序时的栈切换操作**

![image-20231104135028054](https://raw.githubusercontent.com/Enid1107/TyporaImgBed/main/Img/202311041350118.png)

处理器必须借助IRET指令才能从异常/中断处理程序返回。IRET指令与RET指令极其相似，只不过IRET指令会还原之前保存的EFLAGS寄存器值。EFLAGS寄存器的IOPL标志位只有在CPL=0时才可被还原，而F标志位只有在CPL<=IOPL时才能改变。如果在执行处理程序时发生过栈空间切换，那么执行IRET指令将切换回被中断程序栈。

中断和异常向量同在一张IDT内，只是它们的向量号不同罢了。IDT表的前32个向量号被异常占用，而且每个异常的向量号固定不能更改，从向量号32开始被中断处理程序所用。

### IDT的初始化模块

```assembly
setup_IDT:							
	leaq	ignore_int(%rip),	%rdx
	movq	$(0x08 << 16),	%rax
	movw	%dx,	%ax
	movq	$(0x8E00 << 32),	%rcx		
	addq	%rcx,	%rax
	movl	%edx,	%ecx
	shrl	$16,	%ecx
	shlq	$48,	%rcx
	addq	%rcx,	%rax
	shrq	$32,	%rdx
	leaq	IDT_Table(%rip),	%rdi
	mov	$256,	%rcx
rp_sidt:
	movq	%rax,	(%rdi)
	movq	%rdx,	8(%rdi)
	addq	$0x10,	%rdi
	dec	%rcx
	jne	rp_sidt
```

`setup_IDT ` 初始化中断描述符表IDT内的每个中断描述符（共256项，每项占16 B)

`leaq	ignore_int(%rip),	%rdx`  RIP 寻址来获取 `ignore_int` 的地址

`movq	$(0x08 << 16),	%rax`   结构信息的低8字节 `0x08` 通常指向内核代码段的选择子

` movw	%dx,	%ax`  将 `rdx` 寄存器的低16位（即 `dx`）移动到 `rax` 寄存器的低16位上，这实际上是将 `ignore_int` 函数的偏移地址的低16位放入 IDT 条目的偏移字段

`movq	$(0x8E00 << 32),	%rcx`    `0x8E00` 包含中断描述符的属性，`0x8E` 表示中断门类型，包括存在位、特权级别和段选择子

`addq	%rcx,	%rax`    将 `rcx` 寄存器的值加到 `rax` 寄存器的值上，组合成一个完整的 IDT 条目

`movl %edx, %ecx`     构造 IDT 条目的高32位

`shrl	$16,	%ecx`    将 `rcx` 寄存器的内容右移 16 位

`shlq	$48,	%rcx`   将 `rcx` 寄存器的内容左移 48 位，这样做是为了将 `ignore_int` 的偏移地址的高16位放到 64 位 IDT 条目的正确位置

`addq %rcx, %rax`   将 `rcx` 寄存器的值加到 `rax` 寄存器的值上，完成 IDT 条目的构造

`shrq $32, %rdx`  将 `rdx` 寄存器的内容右移 32 位，获取 `ignore_int` 地址的高32位

`leaq IDT_Table(%rip), %rdi`  加载 `IDT_Table` 标签的地址到 `rdi` 寄存器

`mov $256, %rcx`  将立即数 `256` 移动到 `rcx` 寄存器，设置循环计数

`rp_sidt:`   将这256个中断描述符项统一初始化

`movq %rax, (%rdi)`  将 `rax` 寄存器的值（IDT 条目的低64位）移动到 `rdi` 指向的内存地址，即 IDT 表的当前条目

`movq %rdx, 8(%rdi)`  将 `rdx` 寄存器的值（IDT 条目的高64位）移动到 `rdi` 指向的内存地址偏移8字节的地方，即 IDT 条目的下一个部分，这里存放的是中断处理函数的高32位地址

`addq	$0x10,	%rdi`   将 `rdi` 寄存器的值增加16（`0x10`），这是因为每个IDT条目是16字节的大小，这样就可以指向下一个IDT条目

` dec %rcx`   递减 `rcx` 寄存器的值，这是循环计数器，用于跟踪我们已经设置了多少个IDT条目

`  jne rp_sidt`   如果 `rcx` 寄存器的值不为零（这意味着还有更多的IDT条目需要设置），跳转回 `rp_sidt` 标签处，继续循环

### TSS Descriptor进行初始化

TSS是任务状态段描述符

这部分程序负责初始化GDT ( IA-32e模式）内的TSS Descriptor，并通过LTR汇编指令把TSSDescriptor的选择子加载到TR寄存器中。

```assembly
setup_TSS64:
	leaq	TSS64_Table(%rip),	%rdx
	xorq	%rax,	%rax
	xorq	%rcx,	%rcx
	movq	$0x89,	%rax
	shlq	$40,	%rax
	movl	%edx,	%ecx
	shrl	$24,	%ecx
	shlq	$56,	%rcx
	addq	%rcx,	%rax
	xorq	%rcx,	%rcx
	movl	%edx,	%ecx
	andl	$0xffffff,	%ecx
	shlq	$16,	%rcx
	addq	%rcx,	%rax
	addq	$103,	%rax
	leaq	GDT_Table(%rip),	%rdi
	movq	%rax,	64(%rdi)
	shrq	$32,	%rdx
	movq	%rdx,	72(%rdi)

	mov	$0x40,	%ax
	ltr	%ax

	movq	go_to_kernel(%rip),	%rax		/* movq address */
	pushq	$0x08
	pushq	%rax
	lretq
```

`leaq TSS64_Table(%rip), %rdx` : 计算 `TSS64_Table` 的地址并将其放入 `rdx` 寄存器。`TSS64_Table` 是TSS的地址

`xorq %rax, %rax` `xorq %rcx, %rcx`  :清零 `rax` 和 `rcx` 寄存器。`xorq` 是将寄存器与自己异或，结果总是0。

`movq $0x89, %rax`    :将值 `0x89` 移入 `rax` 寄存器。`0x89` 是TSS描述符的类型代码，表示这是一个可用的64位TSS

`shlq $40, %rax` : 将 `rax` 寄存器的值左移40位，为构建TSS描述符的一部分做准备

`movl %edx, %ecx`  : 将 `edx` 寄存器的低32位复制到 `ecx` 寄存器

`shrl $24, %ecx`  ：将 `ecx` 寄存器的值右移24位

`shlq $56, %rcx` : 将 `rcx` 寄存器的值左移56位

`addq %rcx, %rax` : 将 `rcx` 寄存器的值加到 `rax` 寄存器的值上

`xorq %rcx, %rcx` :  再次清零 `rcx` 寄存器

`movl %edx, %ecx` :  将 `edx` 寄存器的低32位复制到 `ecx` 寄存器

`andl $0xffffff, %ecx` : 将 `ecx` 寄存器的值与 `0xffffff` 进行逻辑与操作，这是为了获取 `TSS64_Table` 地址的低24位

`addq %rcx, %rax` : 将 `rcx` 寄存器的值加到 `rax` 寄存器的值上，此时 `rax` 中包含了TSS描述符的低64位

`addq $103, %rax`  : 将103加到 `rax` 寄存器的值上，设置了TSS的大小

`leaq GDT_Table(%rip), %rdi` : 计算 `GDT_Table` 的地址并将其放入 `rdi` 寄存器。`GDT_Table` 是全局描述符表的地址

`movq %rax, 64(%rdi)`  :  将 `rax` 寄存器的值（TSS描述符的低64位）写入 `GDT_Table` 中TSS描述符的位置

`movq %rdx, 72(%rdi)` : 将 `rdx` 寄存器的值（TSS描述符的高64位）写入 `GDT_Table` 中TSS描述符的高部分

到这里，TSS描述符已经设置好了。

`mov $0x40, %ax`  `ltr %ax` : 加载TSS描述符到任务寄存器（TR）。`0x40` 是GDT中TSS描述符的选择子。

剩下代码：返回到内核的栈，并执行了一个远返回（`lretq`）。它加载了 `go_to_kernel` 地址到 `rax`，然后将内核代码段选择子和该地址推送到栈上，之后 `lretq` 指令会将CS和RIP寄存器设置为这些值，从而跳转到内核代码。这通常在从用户空间切换到内核空间时使用

### 实现异常/中断处理模块ignore_int

```assembly
//=======	ignore_int

ignore_int:
	cld
	pushq	%rax
	pushq	%rbx
	pushq	%rcx
	pushq	%rdx
	pushq	%rbp
	pushq	%rdi
	pushq	%rsi

	pushq	%r8
	pushq	%r9
	pushq	%r10
	pushq	%r11
	pushq	%r12
	pushq	%r13
	pushq	%r14
	pushq	%r15

	movq	%es,	%rax
	pushq	%rax
	movq	%ds,	%rax
	pushq	%rax

	movq	$0x10,	%rax
	movq	%rax,	%ds
	movq	%rax,	%es

	leaq	int_msg(%rip),	%rax			/* leaq get address */
	pushq	%rax
	movq	%rax,	%rdx
	movq	$0x00000000,	%rsi
	movq	$0x00ff0000,	%rdi
	movq	$0,	%rax
	callq	color_printk
	addq	$0x8,	%rsp

Loop:
	jmp	Loop	

	popq	%rax
	movq	%rax,	%ds
	popq	%rax
	movq	%rax,	%es

	popq	%r15
	popq	%r14
	popq	%r13
	popq	%r12
	popq	%r11
	popq	%r10
	popq	%r9
	popq	%r8

	popq	%rsi
	popq	%rdi
	popq	%rbp
	popq	%rdx
	popq	%rcx
	popq	%rbx
	popq	%rax
	iretq

int_msg:
	.asciz "Unknown interrupt or fault at RIP\n"
```

这段程序先保存各个寄存器值，而后将DS和ES段寄存器设置成内核数据段，紧接着将为color_printk函数准备参数，并采用寄存器传递方式向其传递参数。提示信息显示后，再执行JMP指令死循环在ignore_int模块里。

在x64模式下，大部分编译器采用寄存器传递参数,参数按照从左向右的顺序依次是RDI、RSI、RDX、RCX、R8、R9，剩余参数使用内存传递方式，RAX放置函数的返回值，调用者负责平衡栈。

![image-20231108132502379](C:/Users/12131/AppData/Roaming/Typora/typora-user-images/image-20231108132502379.png)

![image-20231108132533012](C:/Users/12131/AppData/Roaming/Typora/typora-user-images/image-20231108132533012.png)

![image-20231108132600434](C:/Users/12131/AppData/Roaming/Typora/typora-user-images/image-20231108132600434.png)

后面发现ignore_int模块调用color_printk函数，是使用RDI寄存器保存字体颜色，RSI寄存器保存背景颜色，RDX寄存器保存待显示的字符串起始地址。

#### 除法异常

为了验证处理器的异常捕获效果，特在start_Kernel函数中加入代码i = 1/0 ;来触发#DE（除法）异常，代码清单4-39是此行代码的插入位置。

```c
void Start_Kernel(void)
{
    ……
    i = 1/0;
	while(1);
}
```

编译以下main.c

出现报错，但是正常的，还是可以使用

![image-20231107194750790](C:/Users/12131/AppData/Roaming/Typora/typora-user-images/image-20231107194750790.png)

然后继续生成system，生成kernel.bin，进行挂载cp进软盘，运行。

可以看到有报错提醒

![image-20231108132130855](C:/Users/12131/AppData/Roaming/Typora/typora-user-images/image-20231108132130855.png)

## 系统异常处理（二）

## 为各异常量身定做处理函数(初始化系统中断向量（Interrupt Vector）的函数)

```c
void sys_vector_init()
{
	set_trap_gate(0,1,divide_error);  
	set_trap_gate(1,1,debug);
	set_intr_gate(2,1,nmi);
	set_system_gate(3,1,int3);
	set_system_gate(4,1,overflow);
	set_system_gate(5,1,bounds);
	set_trap_gate(6,1,undefined_opcode);
	set_trap_gate(7,1,dev_not_available);
	set_trap_gate(8,1,double_fault);
	set_trap_gate(9,1,coprocessor_segment_overrun);
	set_trap_gate(10,1,invalid_TSS);
	set_trap_gate(11,1,segment_not_present);
	set_trap_gate(12,1,stack_segment_fault);
	set_trap_gate(13,1,general_protection);
	set_trap_gate(14,1,page_fault);
	//15 Intel reserved. Do not use.
	set_trap_gate(16,1,x87_FPU_error);
	set_trap_gate(17,1,alignment_check);
	set_trap_gate(18,1,machine_check);
	set_trap_gate(19,1,SIMD_exception);
	set_trap_gate(20,1,virtualization_exception);

	//set_system_gate(SYSTEM_CALL_VECTOR,7,system_call);

}
```

这段程序为各个异常向量配置了处理函数和栈指针，此处使用64位TSS里的IST1区域来记录栈基地址。

`set_trap_gate(0,1,divide_error);`   设置0号中断向量，通常用于处理除法错误（比如除以零）。`set_trap_gate` 函数可能会在IDT（中断描述符表）中配置一个陷阱门（trap gate）。

`set_trap_gate(1,1,debug);`  设置1号中断向量，用于处理调试异常。

`set_intr_gate(2,1,nmi);`  设置2号中断向量，用于非屏蔽中断（NMI，Non-Maskable Interrupt）。

`set_system_gate(3,1,int3);`  设置3号中断向量，通常用于断点异常（Breakpoint Exception）。









